const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":104,\"nextId\":104,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"4\",\"4\":\"4#vue3如果用setup写怎么组织代码\",\"5\":\"5\",\"6\":\"6\",\"7\":\"6#一、首先在index-js中获取应用实例\",\"8\":\"6#二、在index-wxml中使用标签\",\"9\":\"6#三、效果图\",\"10\":\"7\",\"11\":\"7#一、问-angular是什么-请简要介绍一下angular框架的特点和优势。\",\"12\":\"7#特点\",\"13\":\"7#优势\",\"14\":\"7#二、问-解释一下angular中的单向数据流是什么-以及它与双向数据绑定的区别。\",\"15\":\"7#问-什么是angular组件-component-请解释一下组件的结构和用法。\",\"16\":\"7#组件结构\",\"17\":\"7#组件用法\",\"18\":\"7#问-angular中的模块-module-是什么-请说明一下模块的作用和如何定义和使用模块。\",\"19\":\"7#模块的作用\",\"20\":\"7#定义模块\",\"21\":\"7#使用模块\",\"22\":\"7#问-解释一下angular中的服务-service-是什么-以及为什么使用服务来共享数据和逻辑。\",\"23\":\"7#服务是什么\",\"24\":\"7#为什么使用服务来共享数据和逻辑\",\"25\":\"7#问-请解释一下angular中的依赖注入-dependency-injection-是什么-以及如何在组件或服务中使用依赖注入。\",\"26\":\"7#依赖注入是什么\",\"27\":\"7#如何使用依赖注入\",\"28\":\"7#问-angular中的指令-directive-有哪些不同的类型-请举例说明它们的用法。\",\"29\":\"7#组件-component\",\"30\":\"7#属性指令-attribute-directive\",\"31\":\"7#结构指令-structural-directive\",\"32\":\"7#问-解释一下angular中的路由-routing-是什么-以及如何配置和使用路由来实现单页面应用。\",\"33\":\"7#路由是什么\",\"34\":\"7#如何配置和使用路由\",\"35\":\"7#问-angular中的表单处理有哪些不同的方式-请举例说明模板驱动表单和响应式表单的区别和用法。\",\"36\":\"7#模板驱动表单\",\"37\":\"7#响应式表单\",\"38\":\"7#区别和用法\",\"39\":\"7#问-解释一下angular中的生命周期钩子函数是什么-包括ngoninit、ngonchanges和ngondestroy等常用钩子函数的作用和执行顺序。\",\"40\":\"7#执行顺序\",\"41\":\"8\",\"42\":\"8#_1-生命周期钩子\",\"43\":\"8#_2-指令分类\",\"44\":\"8#_3-父子组件之间的数据传递\",\"45\":\"8#_4-双向数据绑定的原理\",\"46\":\"8#_5-组件和指令的区别\",\"47\":\"8#_6-ng-content指令\",\"48\":\"8#_7-router-navigate-的使用\",\"49\":\"8#_8-什么是viewencapsulation\",\"50\":\"8#_9-routeroutlet\",\"51\":\"8#_10-数据引用\",\"52\":\"8#_11-有几种数据绑定方式\",\"53\":\"8#_12-单页面应用和传统的web技术有什么不同\",\"54\":\"8#_13-observables-和promises的区别\",\"55\":\"8#_14-asyncpipe\",\"56\":\"8#_15-authentication-and-authorization的区别\",\"57\":\"8#_16-aot编译-和jit编译\",\"58\":\"8#_17-什么是redux\",\"59\":\"8#_18-什么是pipes\",\"60\":\"8#_19-ng-class-和-ng-style的区别\",\"61\":\"8#_20-component和module的区别\",\"62\":\"8#_21-怎样在组件中选择一个元素\",\"63\":\"8#_22-设置base-href-标签的作用\",\"64\":\"8#_23-observer-observable\",\"65\":\"8#_24-constructor-和-ngoninit-的本质区别\",\"66\":\"8#_25-angular的懒加载\",\"67\":\"8#_26-如何优化angular-2应用程序来获得更好的性能\",\"68\":\"8#_27-使用angular的好处\",\"69\":\"8#_28-angular的核心部件有哪些\",\"70\":\"8#_29-列举一下angular中的filter类型\",\"71\":\"8#_30-dirty-check是怎么回事\",\"72\":\"8#_31-dom和bom的区别是什么\",\"73\":\"8#_32-模板驱动表单和-响应式表单的比较\",\"74\":\"8#_33-contentchild-与-viewchild-的异同点\",\"75\":\"9\",\"76\":\"9#一、什么延迟加载的方式都不加\",\"77\":\"9#二、async延迟方式\",\"78\":\"9#三、defer延迟方式\",\"79\":\"9#四、defer与async的区别\",\"80\":\"10\",\"81\":\"10#一、vue2-和-vue3-双向绑定-方法不同\",\"82\":\"10#vue3代码示例\",\"83\":\"10#vue2使用vue3写法代码示例\",\"84\":\"10#二、object-defineproperty-与new-proxy-的比较\",\"85\":\"10#总结\",\"86\":\"11\",\"87\":\"12\",\"88\":\"13\",\"89\":\"14\",\"90\":\"14#一、ref-基本类型\",\"91\":\"14#二、reactive-复杂类型\",\"92\":\"14#三、toref-解构某一个值\",\"93\":\"14#四、torefs-解构多个值\",\"94\":\"15\",\"95\":\"15#一、组件不使用teleport代码示例及效果演示\",\"96\":\"15#二、使用teleport传送门代码示例及效果演示\",\"97\":\"15#总结\",\"98\":\"16\",\"99\":\"17\",\"100\":\"18\",\"101\":\"19\",\"102\":\"20\",\"103\":\"21\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[2,33],\"4\":[2,130],\"5\":[3,19],\"6\":[2],\"7\":[3,24],\"8\":[4,13],\"9\":[2,1],\"10\":[1],\"11\":[5,11],\"12\":[1,24],\"13\":[1,25],\"14\":[5,45],\"15\":[5,15],\"16\":[1,53],\"17\":[1,52],\"18\":[6,8],\"19\":[1,11],\"20\":[1,34],\"21\":[1,33],\"22\":[6,7],\"23\":[1,16],\"24\":[1,24],\"25\":[7,10],\"26\":[1,18],\"27\":[1,54],\"28\":[6,9],\"29\":[3,35],\"30\":[4,35],\"31\":[4,48],\"32\":[6,11],\"33\":[1,14],\"34\":[1,62],\"35\":[4,10],\"36\":[1,56],\"37\":[1,75],\"38\":[1,22],\"39\":[5,45],\"40\":[1,20],\"41\":[1],\"42\":[2,39],\"43\":[2,13],\"44\":[2,18],\"45\":[2,9],\"46\":[2,14],\"47\":[4,18],\"48\":[5,7],\"49\":[2,10],\"50\":[2,8],\"51\":[2,9],\"52\":[3,4],\"53\":[3,17],\"54\":[3,15],\"55\":[3,8],\"56\":[5,21],\"57\":[4,51],\"58\":[3,4],\"59\":[3,4],\"60\":[5,5],\"61\":[3,12],\"62\":[3,6],\"63\":[5,14],\"64\":[3,42],\"65\":[5,30],\"66\":[2,34],\"67\":[2,18],\"68\":[2,10],\"69\":[3,30],\"70\":[2,8],\"71\":[4,5],\"72\":[3,19],\"73\":[3,20],\"74\":[5,26],\"75\":[3,21],\"76\":[2,63],\"77\":[2,60],\"78\":[2,54],\"79\":[2,22],\"80\":[3],\"81\":[6],\"82\":[1,44],\"83\":[1,58],\"84\":[6,43],\"85\":[1,30],\"86\":[3,19],\"87\":[3,14],\"88\":[3,90],\"89\":[2],\"90\":[3,31],\"91\":[3,33],\"92\":[3,35],\"93\":[3,39],\"94\":[2],\"95\":[3,66],\"96\":[2,57],\"97\":[1,6],\"98\":[1,3],\"99\":[1],\"100\":[1],\"101\":[1],\"102\":[2],\"103\":[1]},\"averageFieldLength\":[2.644230769230769,26.489882388310555],\"storedFields\":{\"0\":{\"h\":\"后端客栈\"},\"1\":{\"h\":\"前端客栈\"},\"2\":{\"h\":\"面试汇总\"},\"3\":{\"h\":\"vue2和vue3区别？\",\"t\":[\"1. Vue2 和 Vue3 双向绑定 方法不同 Vue2 : Object.defineProperty() ***后添加的属性是劫持不到的 Vue3 : new Proxy() ***即使后添加的也可以劫持到 ***还不需要循环 3. $set在vue3中没有，因为new Proxy不需要 4. 关于写法 vue2是选项式API vue3可以向下兼容（选项式API），也可以组合式api或Setup语法糖形式 5. v-if和v-for优先级不同了 6. $ref和$children也不同 7. 如果大家还知道其他api不同点，随便说说就可以了 \"]},\"4\":{\"h\":\"vue3如果用setup写怎么组织代码？\",\"t\":[\"说明：hooks（就是函数式），主要让功能模块细分（提升项目的维护性） 解决问题：<script setup> //代码==》比较乱 </script> 面试题：你们vue3写代码的方式 ==〉setup形式 解决：hooks \",\"vue3如果用setup写如何获取类似于vue2中的this？\",\"import { getCurrentInstance } from 'vue' let app = getCurrentInstance(); console.log( app.appContext.app.config.globalProperties.$loading ) \",\"vue3常用api有哪些？\",\"1. createApp() ==》 创建一个应用实例。 说明：等于Vue2的==》new Vue() 使用场景：写插件(封装全局组件会使用) 2. provide/inject ==》依赖注入 说明：其实就是传值 使用场景：某一个父组件传值 到后代组件，如果层级过多传递麻烦，所以使用 缺点：不好维护和查询数据来源 3. directive 说明：自定义指令 场景：后台管理系统中的按钮权限控制（ 一个用户拥有某些权限，但是只能查看和修改，不能删除） 4. mixin 说明：1.全局混入 2. 局部 场景：可以添加生命周期，我在小程序的分享功能会用到 缺点：不好维护和查询数据来源 5. app.config.globalProperties 说明：获取vue这个全局对象的属性和方法 场景：自己封装插件的时候需要把方法添加到对象中 6. nextTick 说明：等待下一次 DOM 更新刷新的工具方法 ：nextTick返回一个Pormise，回调函数是放在Promise中的，所以是异步执行的 场景：就是把dom要更新，那么vue是数据驱动dom，所以数据的赋值就要在nextTick进行 7. computed 说明：计算属性 场景：有缓存 8. reactive、ref 说明：来定义数据的和vue2的data类似 9. watch 说明：监听（Vue3不需要深度监听） 10. markRaw() 说明：不被new Proxy代理，说白了就是静态的数据 11. defineProps() 说明：父组件传递的值，子组件使用setup的形式，需要用defineProps接收 12. defineEmits() 当前组件使用setup形式，自定义事件需要使用defineEmits 13. slot 说明：分为 1. 匿名 2. 具名 3. 作用域 场景：后台管理系统，左侧是固定菜单，右侧是不固定内容，那么右侧就是slot \",\"请介绍一下vue3常用的响应式数据类型\",\"ref ：基本类型 reactive ：复杂类型 toRef ：解构某一个值 toRefs ： 解构多个值 \",\"请介绍一下teleport组件及其使用场景\",\"teleport组件是一个传送门 假如自己写弹出框，需要在页面居中位置展示，不受当前组件的限制，可以把盒子传送到body中 \"]},\"5\":{\"h\":\"02-vue3如果用setup写怎么组织代码？\",\"t\":[\"说明：hooks（就是函数式），主要让功能模块细分,（提升项目的维护性） 解决问题：<script setup> //代码==》比较乱 </script> 面试题：你们vue3写代码的方式 ==〉setup形式 解决：使用hooks去管理维护代码 \"]},\"6\":{\"h\":\"web-view的用法\"},\"7\":{\"h\":\"一、首先在index.js中获取应用实例\",\"t\":[\"Page({ data: { url: 'https://xxxxx.cn', //这里可以修改为自己所需要的外部链接 }, onLoad(options) { if (options.webViewUrl) { this.setData({ url: decodeURIComponent(options.webViewUrl) }); } else { this.generateUrl(); } }, onShow() { }, generateUrl() { const url = `${this.data.url}`; console.log('url', url); this.setData({ url }); } }) \"]},\"8\":{\"h\":\"二、在index.wxml中使用 标签\",\"t\":[\"<view class=\\\"container\\\"> <web-view src=\\\"{{url}}\\\"></web-view> </view> \"]},\"9\":{\"h\":\"三、效果图\",\"t\":[\"​\\t\"]},\"10\":{\"h\":\"Angular最新面试题\"},\"11\":{\"h\":\"一、问: Angular是什么？请简要介绍一下Angular框架的特点和优势。\",\"t\":[\"Angular是一个由Google维护的开源前端框架，用于构建高效、动态和响应式的单页面Web应用程序。它最初在2010年作为AngularJS发布，并于2016年进行了重写并改名为Angular（也被称为Angular 2+）。Angular提供了一种结构化的方式来组织代码，使其易于理解和维护。\",\"以下是Angular框架的一些特点和优势：\"]},\"12\":{\"h\":\"特点\",\"t\":[\"组件化：Angular的核心概念是组件，这是一种自包含的视图和逻辑单元。每个组件可以有自己的HTML模板、CSS样式和TypeScript类。\",\"模块化：Angular使用模块来组织应用的不同部分，包括组件、指令、管道和其他依赖项。\",\"双向数据绑定：Angular通过其强大的数据绑定机制实现了模型与视图之间的自动同步。\",\"依赖注入：Angular采用依赖注入模式来管理服务和组件间的依赖关系，使得代码更易于测试和复用。\",\"指令系统：Angular允许开发者创建自定义指令来扩展HTML元素的功能。\",\"路由与导航：内置的路由器支持多视图和深层链接，提供了丰富的导航功能。\",\"响应式编程：Angular利用RxJS库支持响应式编程范式，简化异步处理。\"]},\"13\":{\"h\":\"优势\",\"t\":[\"跨平台能力：Angular不仅适用于浏览器环境，还可以借助Angular Universal实现服务器端渲染，以及通过Angular Mobile Toolkit开发原生移动应用。\",\"类型安全：基于TypeScript构建，提供静态类型检查，提高代码质量和可维护性。\",\"工具链支持：Angular CLI为开发者提供了命令行工具，方便项目的初始化、构建、测试和部署。\",\"测试友好：Angular的设计鼓励测试驱动开发，内置了对单元测试和端到端测试的支持。\",\"社区活跃：拥有庞大的开发者社区和丰富的第三方库，便于获取帮助和集成其他技术栈。\",\"这些特点和优势使Angular成为构建企业级Web应用的理想选择。\"]},\"14\":{\"h\":\"二、问: 解释一下Angular中的单向数据流是什么，以及它与双向数据绑定的区别。\",\"t\":[\"Angular中的单向数据流是指数据从父组件流向子组件的传递方式。在这种模式下，父组件通过属性（props）将数据传给子组件，而子组件不能直接修改这些数据。如果子组件需要更新数据，它会通过事件（event）通知父组件，由父组件来做出相应的数据更改。\",\"相比之下，双向数据绑定是一种允许数据在模型（Model）和视图（View）之间自动同步的技术。当模型发生变化时，视图会自动更新；同样地，当用户通过视图输入信息时，模型也会相应地进行更新。这种机制使得开发者无需手动处理数据同步问题，简化了开发过程。\",\"Angular中传统的双向数据绑定主要通过ngModel指令实现，特别是在表单控件中使用。然而，在更复杂的场景下，特别是涉及到组件之间的通信时，Angular通常推荐使用单向数据流来保证代码的可预测性和易于调试性。这是因为单向数据流使得数据流动的方向更为明确，减少了因多个组件同时修改同一份数据而导致的潜在问题。\",\"尽管Vue.js和React等其他框架支持一种称为“单向数据流”的概念，但Angular也提供了一种变通的方法，即通过输出（output）事件和输入（input）属性来模拟双向数据绑定的效果。这样可以确保数据仍然遵循单向流动的原则，同时提供了类似双向数据绑定的便利性。\"]},\"15\":{\"h\":\"问: 什么是Angular组件（Component）？请解释一下组件的结构和用法。\",\"t\":[\"Angular组件是Angular应用的主要构建块，它是一个独立的、可重用的代码单元，用于展示用户界面（UI）的一部分。每个组件通常包含三个主要部分：模板（Template）、类（Class）和元数据（Metadata）。这些部分共同定义了组件的外观和行为。\"]},\"16\":{\"h\":\"组件结构\",\"t\":[\"模板：这是一个HTML文件，用于描述组件的视图结构和布局。它可以包含文本、属性绑定、指令和其他Angular特性。\",\"类：这是一个TypeScript类，负责处理组件的行为逻辑。这包括与用户交互、处理事件、访问服务以及操作数据。\",\"元数据：这是通过装饰器（Decorator）提供的信息，用于告诉Angular如何处理这个组件。例如@Component()装饰器包含了组件的模板和样式表等信息。\",\"一个简单的Angular组件示例可能如下所示：\",\"import { Component } from '@angular/core'; @Component({ selector: 'app-hello-world', template: `<h1>Hello, {{name}}!</h1>`, styles: ['h1 {color: blue;}'] }) export class HelloWorldComponent { name = 'World'; } \",\"在这个例子中：\",\"selector定义了在HTML中使用该组件的方式，这里是<app-hello-world>。\",\"template定义了组件的HTML内容，这里是一个带有插值绑定的标题标签。\",\"styles定义了内联CSS样式。\",\"类HelloWorldComponent包含了组件的数据和方法，这里有一个名为name的属性。\"]},\"17\":{\"h\":\"组件用法\",\"t\":[\"要使用这个组件，首先需要将其声明在某个模块中，然后在相应的HTML文件中使用组件的selector标签来插入组件。\",\"import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HelloWorldComponent } from './hello-world.component'; @NgModule({ declarations: [ HelloWorldComponent ], imports: [ BrowserModule ], bootstrap: [HelloWorldComponent] }) export class AppModule { } \",\"接下来，在index.html或其他适当的位置添加<app-root></app-root>标签，表示应用程序的根元素。当Angular启动时，它会找到这个标签并替换为应用程序的顶级组件，即上面定义的HelloWorldComponent。\",\"<!DOCTYPE html> <html> <head> <base href=\\\"/\\\"> <title>Angular App</title> </head> <body> <app-root></app-root> </body> </html> \",\"最终的结果是在浏览器中显示一个蓝色的标题，其中包含字符串“Hello, World!”。\"]},\"18\":{\"h\":\"问: Angular中的模块（Module）是什么？请说明一下模块的作用和如何定义和使用模块。\",\"t\":[\"Angular中的模块（Module）是组织和打包应用程序代码的主要方式。它提供了一种结构化的方式来管理组件、指令、管道和服务，使代码更易于维护和复用。\"]},\"19\":{\"h\":\"模块的作用\",\"t\":[\"组织和封装：模块帮助将相关的功能和组件分组在一起，使得整个应用更加模块化和可管理。\",\"依赖管理：通过声明依赖关系，模块可以确保在正确的地方提供服务和其他共享资源。\",\"作用域隔离：模块之间的作用域通常是独立的，这意味着一个模块中定义的服务不会自动在其他模块中可用，除非明确地导出或引入。\"]},\"20\":{\"h\":\"定义模块\",\"t\":[\"要定义一个Angular模块，需要使用@NgModule()装饰器。以下是一个简单的模块定义示例：\",\"import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule // 导入通用模块以获取常用指令等 ], declarations: [ // 声明模块内部使用的组件、指令和管道 MyComponent, MyDirective, MyPipe ], exports: [ // 定义哪些组件、指令和管道可以在外部模块中使用 MyComponent, MyPipe ] }) export class MyModule { } \",\"在这个例子中，我们创建了一个名为MyModule的新模块，并导入了CommonModule以获取常用的指令和管道。然后，我们在declarations数组中声明了我们自定义的组件、指令和管道。最后，在exports数组中，我们指定了允许外部模块访问的组件、指令和管道。\"]},\"21\":{\"h\":\"使用模块\",\"t\":[\"要使用一个模块，需要在另一个模块中导入它。例如，假设我们有一个根模块AppModule，我们想在其中使用上面定义的MyModule，我们可以这样做：\",\"import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import { MyModule } from './my.module'; // 导入自定义模块 @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, MyModule // 在imports数组中添加我们的模块 ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } \",\"现在，AppModule就可以访问MyModule中导出的所有组件、指令和管道。\"]},\"22\":{\"h\":\"问: 解释一下Angular中的服务（Service）是什么，以及为什么使用服务来共享数据和逻辑。\",\"t\":[\"Angular中的服务（Service）是一个可注入的类，用于封装应用程序中的业务逻辑和数据。它是一种在组件之间共享代码、处理数据和执行通用任务的有效方式。\"]},\"23\":{\"h\":\"服务是什么\",\"t\":[\"可注入：Angular的服务是通过依赖注入（Dependency Injection, DI）系统注册和管理的，这意味着它们可以在需要的地方被注入到组件或其它服务中。\",\"封装逻辑：服务可以包含与特定功能相关的业务逻辑，例如数据获取、认证、状态管理等。\",\"跨组件共享：服务允许在多个组件间共享相同的逻辑和数据，避免了代码重复和维护复杂性。\"]},\"24\":{\"h\":\"为什么使用服务来共享数据和逻辑\",\"t\":[\"使用服务来共享数据和逻辑有以下几个原因：\",\"复用性：将通用的逻辑放在服务中，可以使这些逻辑在整个应用中得到复用，提高了代码的效率和可读性。\",\"解耦组件：通过服务来处理数据和逻辑，使得组件专注于视图展示，从而降低了组件间的耦合度。\",\"测试方便：由于服务通常不涉及UI相关的内容，因此更容易进行单元测试。\",\"单例模式：默认情况下，每个服务在应用中只创建一个实例，这意味着当多个组件同时访问同一个服务时，它们实际上操作的是同一份数据。\",\"更好的组织结构：将相关的数据和逻辑放入服务中，有助于保持项目的整洁和模块化。\",\"总之，Angular服务提供了一种强大的方法来管理应用程序的业务逻辑和数据，并促进了代码的可重用性和可维护性。\"]},\"25\":{\"h\":\"问: 请解释一下Angular中的依赖注入（Dependency Injection）是什么，以及如何在组件或服务中使用依赖注入。\",\"t\":[\"Angular中的依赖注入（Dependency Injection, DI）是一种设计模式，它允许在不直接创建对象的情况下获取它们的实例。依赖注入系统自动管理对象的生命周期和依赖关系，使得代码更加模块化、可测试和易于维护。\"]},\"26\":{\"h\":\"依赖注入是什么\",\"t\":[\"提供者注册：首先，我们需要定义服务，并将其注册到依赖注入容器中。这可以通过@Injectable()装饰器来完成。\",\"依赖声明：然后，在组件或另一个服务中，我们通过构造函数参数来表示需要依赖的服务或其他资源。\",\"依赖解析：当Angular创建一个组件或服务时，它会查看其构造函数参数列表，查找每个参数所对应的依赖项。如果找到匹配的依赖项，Angular就会将这个依赖项的实例注入到构造函数中。\"]},\"27\":{\"h\":\"如何使用依赖注入\",\"t\":[\"以下是一个简单的例子，展示了如何在组件中使用依赖注入：\",\"import { Component } from '@angular/core'; import { DataService } from './data.service'; @Component({ selector: 'app-root', template: ` <h1>{{title}}</h1> <p>Data: {{data}}</p> `, }) export class AppComponent { title = 'My Angular App'; data: string; constructor(private dataService: DataService) { this.data = dataService.getData(); } } \",\"在这个例子中：\",\"我们有一个名为AppComponent的组件，它依赖于一个名为DataService的服务。\",\"在AppComponent的构造函数中，我们声明了一个名为dataService的参数，类型为DataService。\",\"当Angular创建AppComponent时，它会发现dataService参数，并查找是否已经注册了DataService提供者。\",\"找到DataService提供者后，Angular会调用它的工厂方法创建一个新的DataService实例，并将其注入到AppComponent的构造函数中。\",\"最后，我们在组件类中使用dataService来获取数据并显示在视图中。\",\"同样地，我们也可以在服务中使用依赖注入来访问其他服务或资源。这种机制使得代码更容易复用和测试，因为我们可以轻松地替换掉依赖项的实现，而无需修改依赖它们的组件或服务。\"]},\"28\":{\"h\":\"问: Angular中的指令（Directive）有哪些不同的类型？请举例说明它们的用法。\",\"t\":[\"Angular中的指令主要有三种类型：组件（Component）、属性指令（Attribute Directive）和结构指令（Structural Directive）。\"]},\"29\":{\"h\":\"组件（Component）\",\"t\":[\"组件是Angular应用中最常见的指令类型，它包含了HTML模板、CSS样式以及与之相关的类。组件可以嵌套在其他组件中，并且可以通过属性绑定、事件处理等方式与其他组件通信。例如：\",\"import { Component } from '@angular/core'; @Component({ selector: 'app-hello-world', template: `<h1>Hello, {{name}}!</h1>`, }) export class HelloWorldComponent { name = 'World'; } \",\"在这个例子中，我们创建了一个名为HelloWorldComponent的组件，它有一个名为name的属性，该属性被用于模板中的插值表达式。当我们在HTML中使用<app-hello-world></app-hello-world>标签时，Angular会渲染出这个组件的视图。\"]},\"30\":{\"h\":\"属性指令（Attribute Directive）\",\"t\":[\"属性指令用于改变元素的外观或行为，而不会影响其结构。它们通常以[attribute]的形式出现在元素上。例如，Angular内置的ngClass就是一个属性指令，它可以动态地为元素添加或移除CSS类。以下是一个自定义属性指令的例子：\",\"import { Directive, ElementRef, HostBinding } from '@angular/core'; @Directive({ selector: '[appHighlight]' }) export class HighlightDirective { @HostBinding('style.backgroundColor') backgroundColor; constructor(private el: ElementRef) { this.backgroundColor = 'yellow'; } } \",\"在这个例子中，我们创建了一个名为HighlightDirective的属性指令，它会在元素上设置背景颜色为黄色。要使用这个指令，只需在HTML元素上添加appHighlight属性即可。\"]},\"31\":{\"h\":\"结构指令（Structural Directive）\",\"t\":[\"结构指令用于修改DOM的布局，通过添加、移除或重复DOM元素来改变视图的结构。它们通常以*directive的形式出现在元素上。例如，Angular内置的*ngIf和*ngFor就是结构指令，分别用于根据条件显示/隐藏元素和循环遍历数组。以下是一个自定义结构指令的例子：\",\"import { Directive, TemplateRef, ViewContainerRef } from '@angular/core'; @Directive({ selector: '[appUnless]' }) export class UnlessDirective { constructor( private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef ) {} set appUnless(condition: boolean) { if (!condition) { this.viewContainer.createEmbeddedView(this.templateRef); } else { this.viewContainer.clear(); } } } \",\"在这个例子中，我们创建了一个名为UnlessDirective的结构指令，它类似于*ngIf，但条件取反。要使用这个指令，只需在HTML元素上添加*appUnless=\\\"expression\\\"属性即可。\"]},\"32\":{\"h\":\"问: 解释一下Angular中的路由（Routing）是什么，以及如何配置和使用路由来实现单页面应用。\",\"t\":[\"Angular中的路由（Routing）是一种机制，允许用户在单页面应用（SPA）中导航不同的视图或组件，而无需重新加载整个页面。通过使用路由，可以构建具有多个视图和页面的应用程序，并为用户提供更流畅的用户体验。\"]},\"33\":{\"h\":\"路由是什么\",\"t\":[\"配置：首先，我们需要定义一个路由配置对象，它描述了应用程序中的每个可访问路径以及与之关联的组件。\",\"导航：然后，我们可以在应用程序中使用路由器来导航到这些路径，这可以通过routerLink指令或编程方式实现。\",\"懒加载：对于大型应用程序，Angular还支持懒加载，即只在需要时才加载特定模块及其相关组件，以提高应用的启动速度和性能。\"]},\"34\":{\"h\":\"如何配置和使用路由\",\"t\":[\"以下是一个简单的例子，展示了如何在Angular应用中配置和使用路由：\",\"import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { HomeComponent } from './home/home.component'; import { AboutComponent } from './about/about.component'; const routes: Routes = [ { path: '', component: HomeComponent }, { path: 'about', component: AboutComponent } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { } \",\"在这个例子中：\",\"我们创建了一个名为routes的对象数组，其中包含了两个路由配置项：一个是空路径''，对应于HomeComponent；另一个是'about'路径，对应于AboutComponent。\",\"然后，我们创建了一个名为AppRoutingModule的模块，它导入并配置了RouterModule，并将我们的路由配置传递给forRoot()方法。\",\"最后，我们将AppRoutingModule导出，以便其他模块可以使用它。\",\"要在HTML模板中使用路由，我们可以使用routerLink指令，如下所示：\",\"<nav> <a routerLink=\\\"/\\\">Home</a> <a routerLink=\\\"/about\\\">About</a> </nav> <router-outlet></router-outlet> \",\"在这里，routerLink指令将链接映射到相应的路由路径，而router-outlet占位符是路由器用来渲染当前激活组件的地方。\",\"通过这种方式，我们可以轻松地在Angular应用中实现单页面应用的路由功能。\"]},\"35\":{\"h\":\"问: Angular中的表单处理有哪些不同的方式？请举例说明模板驱动表单和响应式表单的区别和用法。\",\"t\":[\"Angular提供了两种主要的方式来处理表单：模板驱动表单（Template-driven Forms）和响应式表单（Reactive Forms）。这两种方式在实现细节和使用方法上有所不同，但都能帮助我们有效地管理和验证用户输入。\"]},\"36\":{\"h\":\"模板驱动表单\",\"t\":[\"模板驱动表单是基于HTML模板的表单处理方式。它依赖于ngModel指令来建立数据绑定，并通过内置的指令如ngRequired、ngMinlength等进行简单的验证。这种形式的表单适用于较小且简单的需求，其配置和使用通常较为直观。\",\"<form #heroForm=\\\"ngForm\\\" (ngSubmit)=\\\"onSubmit()\\\"> <div> <label for=\\\"name\\\">Name:</label> <input type=\\\"text\\\" id=\\\"name\\\" name=\\\"name\\\" [(ngModel)]=\\\"hero.name\\\" #name=\\\"ngModel\\\" required> <div *ngIf=\\\"name.invalid && (name.dirty || name.touched)\\\"> <div *ngIf=\\\"name.errors.required\\\">Name is required.</div> </div> </div> <!-- Other form controls --> <button type=\\\"submit\\\" [disabled]=\\\"!heroForm.form.valid\\\">Submit</button> </form> \",\"在这个例子中：\",\"我们使用了#heroForm=\\\"ngForm\\\"指令将表单与一个局部变量关联起来。\",\"使用[(ngModel)]双向绑定到组件中的属性。\",\"使用*ngIf条件语句显示验证错误消息。\"]},\"37\":{\"h\":\"响应式表单\",\"t\":[\"响应式表单是一种更灵活和可扩展的表单处理方式，它完全在组件类中创建和管理表单模型。响应式表单允许开发者拥有对表单控件状态和验证过程的完全控制，适合于更复杂的场景。\",\"import { Component } from '@angular/core'; import { FormBuilder, FormGroup, Validators } from '@angular/forms'; @Component({ selector: 'app-hero-form', template: ` <form [formGroup]=\\\"heroForm\\\" (ngSubmit)=\\\"onSubmit()\\\"> <div> <label for=\\\"name\\\">Name:</label> <input type=\\\"text\\\" id=\\\"name\\\" formControlName=\\\"name\\\"> <div *ngIf=\\\"heroForm.get('name').invalid && (heroForm.get('name').dirty || heroForm.get('name').touched)\\\"> <div *ngIf=\\\"heroForm.get('name').errors.required\\\">Name is required.</div> </div> </div> <!-- Other form controls --> <button type=\\\"submit\\\" [disabled]=\\\"!heroForm.valid\\\">Submit</button> </form> ` }) export class HeroFormComponent { heroForm: FormGroup; constructor(private formBuilder: FormBuilder) { this.heroForm = this.formBuilder.group({ name: ['', Validators.required] }); } onSubmit() { if (this.heroForm.valid) { // Process the form data } } } \",\"在这个例子中：\",\"我们使用了FormGroup和FormControl来自定义表单模型。\",\"在构造函数中使用FormBuilder来创建表单控件及其验证规则。\",\"在模板中使用formControlName指令将控件与表单模型关联起来。\"]},\"38\":{\"h\":\"区别和用法\",\"t\":[\"配置位置：模板驱动表单的配置主要在HTML模板中完成，而响应式表单的配置则是在组件类中完成。\",\"灵活性：响应式表单提供了更多的控制权，可以方便地动态添加、删除或修改表单控件，而模板驱动表单在这方面相对较弱。\",\"代码结构：响应式表单使得代码更加模块化和易于测试，因为所有表单逻辑都在组件类中，而模板驱动表单的验证逻辑分散在模板和组件之间。\",\"学习曲线：对于初学者来说，模板驱动表单可能更容易理解和上手，而响应式表单需要更多的时间和经验才能熟练掌握。\",\"选择使用哪种类型的表单取决于具体的应用需求和个人喜好。如果应用程序的表单需求相对简单，模板驱动表单可能是更好的选择；如果需要更高级的功能或者更好的代码组织结构，响应式表单会更适合。\"]},\"39\":{\"h\":\"问: 解释一下Angular中的生命周期钩子函数是什么，包括ngOnInit、ngOnChanges和ngOnDestroy等常用钩子函数的作用和执行顺序。\",\"t\":[\"Angular中的生命周期钩子函数是一组预定义的方法，它们在特定的时刻被Angular框架调用。这些方法提供了执行代码的机会，以便在组件的不同阶段进行操作，如初始化数据、订阅事件、执行清理任务等。\",\"以下是Angular中一些常用的生命周期钩子函数及其作用：\",\"ngOnChanges()：当组件输入属性发生变化时调用。这个方法可以用来检测和响应输入属性的变化。它接收一个SimpleChanges对象作为参数，该对象包含了所有发生改变的输入属性以及它们的新旧值。\",\"ngOnInit()：在第一次ngDoCheck之后调用，此时所有的输入属性已经被设置，并且视图已经初始化完成。这个方法通常用于任何复杂的初始化逻辑，比如获取数据或设置订阅。\",\"ngAfterContentInit()：在组件的内容投影（content projection）完成后调用。这意味着在这个阶段，你可以访问到通过内容投影传入的元素和指令。\",\"ngAfterViewInit()：在组件及其所有子视图完成初始化后调用。这个方法可以用来访问DOM元素并执行与视图相关的操作。\",\"ngDoCheck()：每次变更检测周期时都会调用。此方法可以用来实现自定义变更检测逻辑。\",\"ngAfterViewChecked()：在每个变更检测周期中，组件及其所有子视图被检查后调用。这个方法可以用来处理与视图变化有关的任务。\",\"ngAfterContentChecked()：在每个变更检测周期中，组件的内容投影被检查后调用。这个方法可以用来处理与内容变化有关的任务。\",\"ngOnDestroy()：在组件即将被销毁前调用。这个方法可以用来清理资源，例如取消订阅、释放定时器等。\"]},\"40\":{\"h\":\"执行顺序\",\"t\":[\"以下是一个简化的组件生命周期钩子函数执行顺序：\",\"ngOnChanges()\",\"ngOnInit()\",\"ngDoCheck()\",\"ngAfterContentInit()\",\"ngAfterContentChecked()\",\"ngAfterViewInit()\",\"ngAfterViewChecked()\",\"ngDoCheck()\",\"...\",\"ngOnDestroy()\",\"注意：\",\"ngOnChanges() 只有在输入属性发生变化时才会被调用。\",\"ngDoCheck() 和 ngAfterViewChecked()/ngAfterContentChecked() 在每次变更检测周期中都会被调用。\",\"组件的生命周期钩子函数执行顺序可能会因为不同的情况而有所变化，比如使用懒加载、路由跳转等。\",\"通过理解并有效利用这些生命周期钩子函数，开发者能够更好地控制组件的行为，确保应用的性能和稳定性。\",\"​\"]},\"41\":{\"h\":\"Angular面试题汇总\"},\"42\":{\"h\":\"1. 生命周期钩子\",\"t\":[\"生命周期的顺序，见下图：\",\"angular面试题及答案_angular面试\",\"钩子方法\",\"用途\",\"ngOnChanges()\",\"当组件数据绑定的输入属性发生变化是触发，该方法接收一个SimpleChanges对象，包括当前值和上一个属性值。**首次调用一定发生在ngOnInit前，**值得注意的是该方法仅限于对象的引用发生变化时才会触发\",\"ngOnInit()\",\"初始化指令或组件，在angular第一次显示展示组件的绑定属性后调用，该方法只会调用一次\",\"ngDoCheck()\",\"检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应\",\"ngAfterContentInit()\",\"当把内容投影进组件之后调用，第一次调用ngDocheck()之后调用，只调用一次，只适用于组件\",\"ngAfterContentChecked()\",\"每次完成被投影组件内容的变更检测之后调用，只适用于组件\",\"ngAfterViewInit()\",\"当 Angular 初始化完组件视图及其子视图或包含该指令的视图之后调用\",\"ngAfterViewChecked()\",\"每次做完组件视图和子视图的变更检测之后调用，只适用于组件\",\"ngOnDestroy()\",\"在angular每次销毁组件或指令之前调用，通常用于移除事件监听，退订可观察对象，以防内存泄露\"]},\"43\":{\"h\":\"2. 指令分类\",\"t\":[\"组件：用于构建UI组件，继承于Directive类\",\"属性指令：用于改变组件的外观或行为\",\"ngClass\",\"ngStyle\",\"结构指令：用于动态添加或删除DOM元素来改变DOM布局\",\"ngIf\",\"ngFor\",\"ngSwitch\",\"自定义指令\"]},\"44\":{\"h\":\"3. 父子组件之间的数据传递\",\"t\":[\"@Input 父组件向子组件传递数据和传递方法(子组件中使用)\",\"@output 子组件传值给父组件 （事件传递的方式）（子组件中使用）\",\"//子组件中使用事件发射器 @output() somethingChanged = new EventEmitter(); somethingChanged.emit(value); \",\"使用@ViewChid父组件通过局部变量获取子组件的引用，主动获取子组件的数据和方法（父组件中使用）\"]},\"45\":{\"h\":\"4. 双向数据绑定的原理\",\"t\":[\"data => view：数据绑定，模板语法 [ ]\",\"view => data: 事件绑定，模板语法（）\",\"angular的双向数据绑定就是 数据绑定 + 事件绑定 ，模板语法 [()]\"]},\"46\":{\"h\":\"5. 组件和指令的区别\",\"t\":[\"component使用注解@Component修饰，directive使用注解@Directive修饰\",\"component是组件化思想，基于组件创建应用，把应用划分成细小的可重复利用的组件，而directive用来在已经存在的DOM元素上实现一些行为\",\"component是可重复使用的组件，directive是可重复使用的行为\",\"component可创建一个view，即template或templateUrl，而directive没有。\"]},\"47\":{\"h\":\"6. ng-content指令？\",\"t\":[\"像p标签或者h1标签，在标记之间可以添加内容， <p>this is a paragraph</p>那我们如果想在angular的标签之间添加内容呢，例如在<app-test></app-test>,这种情况下就可以使用<ng-content>tag directive is used</ng-content> \"]},\"48\":{\"h\":\"7. router.navigate 的使用？\",\"t\":[\"当我们想路由到一个组件的时候使用router.navigatethis.router.navigate(['./component name'])\"]},\"49\":{\"h\":\"8. 什么是ViewEncapsulation\",\"t\":[\"ViewEncapsulation 决定组件中定义的样式是否会影响整个应用程序。在Angular中有三种方法可以做到这一点: Emulated : 样式从其他HTML传播到组件。 Native : 来自其他HTML的样式不会传播到组件。 None:组件中定义的样式对所有组件都是可见的。\"]},\"50\":{\"h\":\"9. RouterOutlet\",\"t\":[\"<router-outlet></router-outlet> 简单理解：页面占位符,决定component显示在哪里，最终会被相应的component的view替换掉\"]},\"51\":{\"h\":\"10. {{}}数据引用\",\"t\":[\"与HTML标签一起使用，<h1>{{var}}</h1> var 是来自于ts（component）中的值。\"]},\"52\":{\"h\":\"11. 有几种数据绑定方式？\",\"t\":[\"属性绑定 [ ]\",\"事件绑定（）\",\"双向数据绑定 [()]\"]},\"53\":{\"h\":\"12. 单页面应用和传统的web技术有什么不同？\",\"t\":[\"在传统的web技术中，客户端请求一个web页面(HTML/JSP/asp)，服务器返回资源(或HTML页面)，客户端再次请求另一个页面，服务器用另一个资源响应。问题就在于请求/响应中消耗了大量时间，或者是重新加载使用了大量时间。而在SPA技术中，即使URL不断变化，我们也只维护一个页面(index.HTML)。\"]},\"54\":{\"h\":\"13. Observables 和Promises的区别\",\"t\":[\"Observables 是惰性的，意思是在subsciption之前什么都不会发生。\",\"​ Promise是eager的，意思是一旦创建，就会执行\",\"Observable是一个stream，可以传递0,1，或者多个事件，并且为每个事件回调。\",\"​ Promise只处理一个事件\",\"Observable可取消\",\"​ Promise不可取消\"]},\"55\":{\"h\":\"14. AsyncPipe ？\",\"t\":[\"当observable或promise返回data时，我们使用一个临时属性来保存内容。稍后，我们将相同的内容绑定到模板。通过使用AsyncPipe, promise或observable可以直接在模板中使用，而不需要临时属性。\"]},\"56\":{\"h\":\"15. Authentication and Authorization的区别？\",\"t\":[\"Authentication (认证) ： 用户登录凭据传递给(服务器上的)认证API。在服务器端验证凭据并返回JSON Web Token(JWT)。JWT是一个JSON对象，它有关于当前用户的一些信息或属性。一旦JWT返回给给客户端，客户端或用户将被该JWT所标记。\",\"Authorization（授权）：登录成功后，经过身份验证或真正的用户不能访问所有内容。用户未被授权访问其他人的数据，他/她被授权访问某些数据。\"]},\"57\":{\"h\":\"16. AOT编译 和JIT编译？\",\"t\":[\"Just-In-Time (JIT) 生成的JS代码，在浏览器中进行。\",\"​ — 大概的开发流程：\",\"​ – 使用Typescript开发\",\"​ – 使用tsc编译\",\"​ – 打包、压缩、部署\",\"​ 部署好之后，用户在浏览器端：\",\"​ – 浏览器下载js代码\",\"​ – angular启动，在浏览器中开始JIT的编译过程\",\"​ – 渲染页面\",\"Ahead-of-Time（AOT）生成的是TS代码\",\"​ — 流程：\",\"​ – typescript开发angular应用\",\"​ – 用ngc编译\",\"​ 用angular编译器对模板进行编译，生成typescript代码\",\"​ typescript编译车JavaScript\",\"​ – 打包部署\",\"​ 用户端\",\"​ – 下载代码\",\"​ – 启动angular\",\"​ – 页面渲染\",\"​ AOT优势\",\"​ 1、渲染得更快\",\"​ 2、需要的异步请求更少\",\"​ 3、需要下载的Angular框架体积更小\",\"​ 4、提早检测模板错误\",\"​ 5、更安全\",\"​ JIT优势\",\"​ 编译时间短，除非确实有动态组件的需求，否则jit唯一的优势就是能用来做在线 Demo和开发调试。\"]},\"58\":{\"h\":\"17. 什么是Redux?\",\"t\":[\"它是一个帮助我们维护应用程序状态的库。简单的数据流应用程序不需要Redux，它用于具有复杂数据流的单页应用程序。\"]},\"59\":{\"h\":\"18. 什么是Pipes?\",\"t\":[\"此功能用于更改模板上的输出;比如将字符串更改为大写并在模板上显示它。它还可以相应地更改日期格式。\"]},\"60\":{\"h\":\"19. ng-Class 和 ng-Style的区别\",\"t\":[\"ng-Class: 加载css类\",\"ng-Style:设置css样式\"]},\"61\":{\"h\":\"20. component和module的区别？\",\"t\":[\"component控制视图（html）.组件之间以及组件和service之间互相交互给app提供功能\",\"module是包括一个或多个组件，module不会控制视图（HTML）。module声明了哪些模块可以被其他模块使用，依赖注入了哪些类，以及启动的component，模块来管理组件，使app实现模块化。\"]},\"62\":{\"h\":\"21. 怎样在组件中选择一个元素？\",\"t\":[\"在组件的constructor中引入 ElementRef 来操作DOM元素 constructor(myElement: ElementRef)\"]},\"63\":{\"h\":\"22. 设置base href 标签的作用？\",\"t\":[\"angular路由器使用base href 作为组件、模板的基地址，开发期间，通常会在index.html所在目录中启动服务器，所以这个目录就是根目录，所以可以在index.html 的顶部添加。 当没有配置base标签时，加载应用会失败。\"]},\"64\":{\"h\":\"23. Observer / Observable\",\"t\":[\"Observable（可观察者） 接受一个Observer作为参数然后返回unsubscribe函数\",\"​ – 特征：\",\"​ — 是一个函数\",\"​ — 接受一个Observer对象（包含next、error、complete方法的对象）作为参数\",\"​ — 返回 unsubscribe 函数，用于取消订阅\",\"​ – 作用：\",\"​ — 作为生产者和观察者之间的桥梁，并返回一种方法来解除生产者和观察者之间的关系，其中观察者用于处理时间序列上的数据流。\",\"Observer (观察者)对象\",\"观察者用来接收可观察者发送过来的消息\",\"var observer = { next : x => console.log('Observer got a next value' + x), error : err => console.error('Observer got a error:' + err), complete: () => console.log('Observer got a complete notification') } 使用 observable.subscribe(observer); \"]},\"65\":{\"h\":\"24. Constructor 和 ngOnInit 的本质区别\",\"t\":[\"Constructor\",\"在ES6中 constructor表示构造函数，使用在class中。来初始化操作。当类被初始化之后，构造函数会被调用\",\"ngOnInit\",\"ngOnInit 是angular中OnInit钩子的实现，用来初始化组件。 ngOnInit : 在angular 第一次显示数据绑定和设置指令、组件的输入属性之后，初始化指令、组件 所以从angular的生命周期看，constructor是执行在先的 所以既然ngOnchanges是输入属性发生变化的时候调用，并且ngOnInit是在ngOnchanges执行之后才调用，而constructor是在组件实例化的时候就调用了，也就是说，在constructor中是取不到输入属性的值的。\",\"使用场景\",\"constructor 中不适合进行任何和组件通信类似的复杂操作，一般在constructor中进行一些简单的初始化操作，比如依赖注入、变量初始化等。\",\"ngOnInit可以用来初始化组件之间通信的，如异步请求等\"]},\"66\":{\"h\":\"25. Angular的懒加载\",\"t\":[\"默认情况下，在初始化的时候所有路由都会加载，导致加载缓慢，启动速度慢，所以可以使用懒加载 懒加载 ： 通俗 的讲就是进入主模块之后，子模块不加载，等真正访问到子模块之后，再去加载。使用loadChildren配置路由 知识点：\",\"RouterModule.forRoot() 用于主模块\",\"RouterModule.forChild() 用于子模块\",\"loadChildren\",\"const routes: Routes = [ {path:'',redirectTo:'child'}, {path:'child',loadChildren:'./children-load/children-load.module#ChildrenLoadModule'}, {path:'childNew',loadChildren:'./children-newload/children-newload.module#ChildrenNewloadModule'} ]; \"]},\"67\":{\"h\":\"26.\",\"t\":[\"1）考虑AOT编译。\",\"2）确保应用程序已经经过了捆绑，uglify和tree shaking。\",\"3）确保应用程序不存在不必要的import语句。\",\"4）确保应用中已经移除了不使用的第三方库。\",\"5）所有dependencies 和dev-dependencies都是明确分离的。\",\"6）如果应用程序较大时，我会考虑延迟加载而不是完全捆绑的应用程序。\"]},\"68\":{\"h\":\"27. 使用Angular的好处\",\"t\":[\"可以添加自定义的directive.\",\"优秀的社区支持。\",\"客户端和服务器的通讯非常便利。\",\"强大的功能比如动画和事件处理。\",\"使用mvc模式。\",\"支持双向数据绑定。\",\"支持依赖注入， restful service和有效验证。\"]},\"69\":{\"h\":\"28. Angular的核心部件有哪些?\",\"t\":[\"1、模块（Modules）\",\"2、组件（Components）\",\"3、模版（Templates）\",\"4、元数据（Metadata）\",\"5、数据绑定（Data Binding）\",\"6、指令（Directives）\",\"7、服务（Services）\",\"8、依赖注入（Dependency Injection）\",\"9、路由（routing）\"]},\"70\":{\"h\":\"29. 列举一下Angular中的filter类型\",\"t\":[\"Currency. Date. Filter. Json. limitTo lowercase number orderBy\"]},\"71\":{\"h\":\"30. Dirty check是怎么回事?\",\"t\":[\"Dirty check是比较新的数据跟老的数据的差别，如果看到有改变, 就用新的数据更新现有的视图。\"]},\"72\":{\"h\":\"31. DOM和BOM的区别是什么?\",\"t\":[\"Dom是document object model。Bom是browser object model。\",\"DOM代表的是网页的内容。Bom包含dom, 它还包含有浏览器的属性。\",\"Dom是一棵树结构，通过对应的API来访问里面的数据。Bom包含在全局的JavaScript对象里面，是window object的子成员。\",\"Dom用来操作html文档。Bom用来操作浏览器窗口。\",\"Dom有w3c的标准。Bom,对各个浏览器来说都是有自己具体的实现，都不一样。\"]},\"73\":{\"h\":\"32. 模板驱动表单和 响应式表单的比较\",\"t\":[\"Template-Driven Forms (模板驱动表单) 的特点\",\"使用方便\",\"适用于简单的场景\",\"通过 [(ngModel)] 实现数据双向绑定\",\"最小化组件类的代码\",\"不易于单元测试\",\"Reactive Forms (响应式表单) 的特点\",\"比较灵活\",\"适用于复杂的场景\",\"简化了HTML模板的代码，把验证逻辑抽离到组件类中\",\"方便的跟踪表单控件值的变化\",\"易于单元测试\"]},\"74\":{\"h\":\"33. ContentChild 与 ViewChild 的异同点\",\"t\":[\"相同点\",\"都是属性装饰器\",\"都有对应的复数形式装饰器：ContentChildren、ViewChildren\",\"都支持 Type(any) |Function|string 类型的选择器\",\"不同点\",\"ContentChild 用来从通过 Content Projection 方式 (ng-content) 设置的视图中获取匹配的元素\",\"ViewChild 用来从模板视图中获取匹配的元素\",\"在父组件的 ngAfterContentInit 生命周期钩子中才能成功获取通过 ContentChild 查询的元素\",\"在父组件的 ngAfterViewInit 生命周期钩子中才能成功获取通过 ViewChild 查询的元素\"]},\"75\":{\"h\":\"01-延迟加载JS有哪些方式？\",\"t\":[\"延迟加载：async、defer 例如：<script defer type=\\\"text/javascript\\\" src='script.js'></script> 例如：<script async type=\\\"text/javascript\\\" src='script.js'></script> defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。 async : async是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。 \"]},\"76\":{\"h\":\"一、什么延迟加载的方式都不加\",\"t\":[\"image-20240518113957978\",\"可见，绿色部分代表的是正在解析html，当遇到一个js时，他会暂停解析html，并去解析js，然后去执行js，最后在开始解析html，直到解析完成\",\"代码示例\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> <script src=\\\"./script.js\\\" text=\\\"text/javascript\\\"></script> </head> <body> <div id=\\\"box\\\">111111</div> </body> </html> \",\"var box = document.getElementById('box'); console.log(box); \",\"image-20240518114706523\",\"可见，获取不到box，这是因为他在解析html时，遇到了js文件，当解析并执行完成js后，才解析之后的html，所以打印的结果为null\"]},\"77\":{\"h\":\"二、async延迟方式\",\"t\":[\"image-20240518114936359\",\"可见，在解析html时，遇到了js，那么他们两个会并行解析，随后执行剩余的代码\",\"代码示例\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> <script async src=\\\"./script.js\\\" text=\\\"text/javascript\\\"></script> </head> <body> <div id=\\\"box\\\">111111</div> </body> </html> \",\"var box = document.getElementById('box'); console.log(box); \",\"image-20240518115317139\",\"可见，可以获取到box，这是因为html解析是遇到js后，他们会存在并行解析，等html与js解析好后，在一起执行\"]},\"78\":{\"h\":\"三、defer延迟方式\",\"t\":[\"image-20240518115959234\",\"可见，等绿色html执行完成后，在执行解析完成的js\",\"代码示例\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Document</title> <script defer src=\\\"./script.js\\\" text=\\\"text/javascript\\\"></script> </head> <body> <div id=\\\"box\\\">111111</div> </body> </html> \",\"var box = document.getElementById('box'); console.log(box); \",\"image-20240518120152985\",\"可见，一样可以获取到box\"]},\"79\":{\"h\":\"四、defer与async的区别\",\"t\":[\"defer：\",\"defer是在等html全部解析完成后，再去执行的js，而且defer去执行js时，是顺次执行\",\"async：\",\"async是html与js共同解析并执行的，而async不按顺次执行，他是等某个js谁先解析完谁先执行\",\"总结来说：\",\"async 更适合于不需要等待页面完整加载即可运行的第三方脚本，因为它提供了更高的灵活性，但可能伴随着一定的执行时机的不确定性。\",\"defer 则是为了确保页面加载完成后才执行脚本，减少因页面未加载完全而引发的错误\",\"建议：\",\"如果项目中使用defer解析js时，某个js2依赖于js1，那么，js1必须放在js2上面，否则会出现js2里面的一些变量属性获取不到，导致js报错\"]},\"80\":{\"h\":\"01-vue2和vue3区别？\"},\"81\":{\"h\":\"一、Vue2 和 Vue3 双向绑定 方法不同\"},\"82\":{\"h\":\"vue3代码示例\",\"t\":[\"<template> <div class=\\\"home\\\"> <img alt=\\\"Vue logo\\\" src=\\\"../assets/logo.png\\\"> {{ obj }} {{ obj.a }} ==> {{ obj.b }} ==> {{ obj.c }} <hr /> <button @click='addBtn'>添加</button> </div> </template> <script setup> import { reactive } from 'vue' let obj = reactive({ a:1, b:2 }); const addBtn = ()=>{ obj.c = 3; } </script> \",\"由此可见，即使vue3中，未使用$set方法，都可以实现数据与页面实时更新\"]},\"83\":{\"h\":\"vue2使用vue3写法代码示例\",\"t\":[\"<template> <div class=\\\"home\\\"> <img alt=\\\"Vue logo\\\" src=\\\"../assets/logo.png\\\"> {{ obj }} {{ obj.a }} ==> {{ obj.b }} ==> {{ obj.c }} <hr /> <button @click='addBtn'>添加</button> </div> </template> <script> export default { name: 'HomeView', data () { return { obj:{ a:1, b:2 } } }, methods:{ addBtn(){ //数据更新了视图没更新 this.obj.c = 3; console.log( this.obj ); } } } </script> \",\"由此可见，vue2项目中使用vue3的写法，那么会导致，数据更新了，但试图未更新\",\"vue2代码使用$set方法，即可实现数据与试图更新\",\"<template> <div class=\\\"home\\\"> <img alt=\\\"Vue logo\\\" src=\\\"../assets/logo.png\\\" /> {{ obj }} {{ obj.a }} ==> {{ obj.b }} ==> {{ obj.c }} <hr /> <button @click=\\\"addBtn\\\">添加</button> </div> </template> <script> export default { name: \\\"HomeView\\\", data() { return { obj: { a: 1, b: 2, }, }; }, methods: { addBtn() { //数据更新了视图没更新 // this.obj.c = 3; // console.log(this.obj); this.$set(this.obj, \\\"c\\\", 3); }, }, }; </script> \",\"由此，我们可以知道，在Vue3中，$set是不存在的，调用时会出现undefined，而在Vue2中，则需要使用到$set方法\"]},\"84\":{\"h\":\"二、Object.defineProperty()与new Proxy()的比较\",\"t\":[\"new Proxy()即使后添加的也可以劫持到，还不需要循环\",\"<script type=\\\"text/javascript\\\"> let data = { a:1, b:2 } let vue = new Proxy(data,{ get( target, propKey, receiver ){ console.log( '获取了' ); return Reflect.get(target, propKey, receiver); }, set( target, propKey, value, receiver ){ console.log( '设置了' ); return Reflect.set(target, propKey, value, receiver); } }) vue.c = 3; console.log( vue.c ) </script> \",\"Object.defineProperty()后添加的属性是劫持不到的\",\"<script type=\\\"text/javascript\\\"> let data = { a:1, b:2 } for( let k in data ){ Object.defineProperty(vue,k,{ get(){ console.log( '获取了' ); return data[k]; }, set( value ){ console.log( '设置了' ); data[k] = value; } }) } // 设置了 vue.c = 3; // 获取了 console.log( vue ); //打印结果只为3，根本没有被劫持到，但vue对象中有c的数据 </script> \"]},\"85\":{\"h\":\"总结\",\"t\":[\"1. Vue2 和 Vue3 双向绑定 方法不同 Vue2 : Object.defineProperty() ***后添加的属性是劫持不到的 Vue3 : new Proxy() ***即使后添加的也可以劫持到 ***还不需要循环 2. $set在vue3中没有，因为new Proxy不需要 3. 关于写法 vue2是选项式API vue3可以向下兼容（选项式API），也可以组合式api或Setup语法糖形式 4. v-if和v-for优先级不同了 5. $ref和$children也不同 \"]},\"86\":{\"h\":\"02-vue3如果用setup写怎么组织代码？\",\"t\":[\"说明：hooks（就是函数式），主要让功能模块细分,（提升项目的维护性） 解决问题：<script setup> //代码==》比较乱 </script> 面试题：你们vue3写代码的方式 ==〉setup形式 解决：使用hooks去管理维护代码 \"]},\"87\":{\"h\":\"03-vue3如果用setup写如何获取类似于vue2中的this？\",\"t\":[\"import { getCurrentInstance } from 'vue' let app = getCurrentInstance(); console.log( app.appContext.app.config.globalProperties.$loading ) \"]},\"88\":{\"h\":\"04-vue3常用api有哪些？\",\"t\":[\"1. createApp() ==》 创建一个应用实例。 说明：等于Vue2的==》new Vue() 使用场景：写插件(封装全局组件会使用) 2. provide/inject ==》依赖注入 说明：其实就是传值 使用场景：某一个父组件传值 到后代组件，如果层级过多传递麻烦，所以使用 缺点：不好维护和查询数据来源 3. directive 说明：自定义指令 场景：后台管理系统中的按钮权限控制（ 一个用户拥有某些权限，但是只能查看和修改，不能删除） 4. mixin 说明：1.全局混入 2. 局部 场景：可以添加生命周期，我在小程序的分享功能会用到 缺点：不好维护和查询数据来源 5. app.config.globalProperties 说明：获取vue这个全局对象的属性和方法 场景：自己封装插件的时候需要把方法添加到对象中 6. nextTick 说明：等待下一次 DOM 更新刷新的工具方法 ：nextTick返回一个Pormise，回调函数是放在Promise中的，所以是异步执行的 场景：就是把dom要更新，那么vue是数据驱动dom，所以数据的赋值就要在nextTick进行 7. computed 说明：计算属性 场景：有缓存 8. reactive、ref 说明：来定义数据的和vue2的data类似 9. watch 说明：监听（Vue3不需要深度监听） 10. markRaw() 说明：不被new Proxy代理，说白了就是静态的数据 11. defineProps() 说明：父组件传递的值，子组件使用setup的形式，需要用defineProps接收 12. defineEmits() 当前组件使用setup形式，自定义事件需要使用defineEmits 13. slot 说明：分为 1. 匿名 2. 具名 3. 作用域 场景：后台管理系统，左侧是固定菜单，右侧是不固定内容，那么右侧就是slot \"]},\"89\":{\"h\":\"05-vue3常用的响应式数据类型\"},\"90\":{\"h\":\"一、ref 基本类型\",\"t\":[\"<template> <div class=\\\"home\\\"> {{ sum }} <button @click='btn'>按钮</button> </div> </template> <script setup> import { ref } from 'vue' let sum = ref(10); const btn = ()=>{ sum.value = 200; // 因为是要改变sum的值，所以需要sum.value } </script> \"]},\"91\":{\"h\":\"二、reactive 复杂类型\",\"t\":[\"<template> <div class=\\\"home\\\"> {{ obj }} <button @click='btn'>按钮</button> </div> </template> <script setup> import { reactive } from 'vue' let obj = reactive({ name:'张三', age:18, sex:'男' }) const btn = ()=>{ obj.name = '王武' } </script> \"]},\"92\":{\"h\":\"三、toRef 解构某一个值\",\"t\":[\"<template> <div class=\\\"home\\\"> {{ name }} <button @click='btn'>按钮</button> </div> </template> <script setup> import { toRef } from 'vue' let obj = reactive({ name:'张三', age:18, sex:'男' }) let name = toRef(obj,'name'); //解构某一个值 const btn = ()=>{ obj.name = '王武' } </script> \"]},\"93\":{\"h\":\"四、toRefs 解构多个值\",\"t\":[\"<template> <div class=\\\"home\\\"> {{ name }} <button @click='btn'>按钮</button> </div> </template> <script setup> import { ref , reactive , toRef , toRefs } from 'vue' let obj = reactive({ name:'张三', age:18, sex:'男' }) let { name , age } = toRefs(obj); // 解构多个值 const btn = ()=>{ name.value = '张小三'; // 改变name的值 } </script> \"]},\"94\":{\"h\":\"06-teleport组件及其使用场景\"},\"95\":{\"h\":\"一、组件不使用 代码示例及效果演示\",\"t\":[\"index.vue代码\",\"<template> <div class=\\\"home\\\"> <A /> <B /> </div> </template> <script setup> import A from '@/components/A' import B from '@/components/B' </script> <style> .home{ display: flex; height: 700px; } </style> \",\"组件A代码\",\"<template> <div style='width:300px;background: red;'> 左边 </div> </template> \",\"组件B代码\",\"<template> <div style=\\\"background: blue;flex:1;\\\" class='box'> 右边 <button @click='btn'>按钮</button> <div class='mo' v-if='show'></div> </div> </template> <script setup> import { ref } from 'vue' let show = ref(false); const btn = ()=>{ show.value=true; } </script> <style> .box{ position: relative; } .mo{ width: 300px; height: 300px; background: orange; position: absolute; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px; } </style> \",\"效果展示\"]},\"96\":{\"h\":\"二、使用teleport传送门代码示例及效果演示\",\"t\":[\"修改组件B代码\",\"<template> <div style=\\\"background: blue;flex:1;\\\" class='box'> 右边 <button @click='btn'>按钮</button> <teleport to=\\\"body\\\"> <div class=\\\"mo\\\" v-if=\\\"show\\\"></div> </teleport> </div> </template> <script setup> import { ref } from 'vue' let show = ref(false); const btn = ()=>{ show.value=true; } </script> <style> .box{ position: relative; } .mo{ width: 300px; height: 300px; background: orange; position: absolute; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px; } </style> \",\"效果展示\"]},\"97\":{\"h\":\"总结\",\"t\":[\"teleport组件是一个传送门 假如自己写弹出框，需要在页面居中位置展示，不受当前组件的限制，可以把盒子传送到body中 \"]},\"98\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"99\":{\"h\":\"Vue\"},\"100\":{\"h\":\"小程序\"},\"101\":{\"h\":\"Angular\"},\"102\":{\"h\":\"Java Script\"},\"103\":{\"h\":\"Vue3\"}},\"dirtCount\":0,\"index\":[[\"小程序\",{\"0\":{\"100\":1}}],[\"修改组件b代码\",{\"1\":{\"96\":1}}],[\"效果展示\",{\"1\":{\"95\":1,\"96\":1}}],[\"效果图\",{\"0\":{\"9\":1}}],[\"右边\",{\"1\":{\"95\":1,\"96\":1}}],[\"右侧是不固定内容\",{\"1\":{\"4\":1,\"88\":1}}],[\"左边\",{\"1\":{\"95\":1}}],[\"左侧是固定菜单\",{\"1\":{\"4\":1,\"88\":1}}],[\"改变name的值\",{\"1\":{\"93\":1}}],[\"张小三\",{\"1\":{\"93\":1}}],[\"张三\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"王武\",{\"1\":{\"91\":1,\"92\":1}}],[\"男\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"根本没有被劫持到\",{\"1\":{\"84\":1}}],[\"打印结果只为3\",{\"1\":{\"84\":1}}],[\"打包部署\",{\"1\":{\"57\":1}}],[\"打包\",{\"1\":{\"57\":1}}],[\"k\",{\"1\":{\"84\":4}}],[\"则需要使用到$set方法\",{\"1\":{\"83\":1}}],[\"则是为了确保页面加载完成后才执行脚本\",{\"1\":{\"79\":1}}],[\"调用时会出现undefined\",{\"1\":{\"83\":1}}],[\"未使用$set方法\",{\"1\":{\"82\":1}}],[\"否则会出现js2里面的一些变量属性获取不到\",{\"1\":{\"79\":1}}],[\"否则jit唯一的优势就是能用来做在线\",{\"1\":{\"57\":1}}],[\"某个js2依赖于js1\",{\"1\":{\"79\":1}}],[\"某一个父组件传值\",{\"1\":{\"4\":1,\"88\":1}}],[\"建议\",{\"1\":{\"79\":1}}],[\"减少因页面未加载完全而引发的错误\",{\"1\":{\"79\":1}}],[\"减少了因多个组件同时修改同一份数据而导致的潜在问题\",{\"1\":{\"14\":1}}],[\"总结\",{\"0\":{\"85\":1,\"97\":1}}],[\"总结来说\",{\"1\":{\"79\":1}}],[\"总之\",{\"1\":{\"24\":1}}],[\"再去执行的js\",{\"1\":{\"79\":1}}],[\"再去加载\",{\"1\":{\"66\":1}}],[\"四\",{\"0\":{\"79\":1,\"93\":1}}],[\"随后执行剩余的代码\",{\"1\":{\"77\":1}}],[\"随便说说就可以了\",{\"1\":{\"3\":1}}],[\"遇到了js\",{\"1\":{\"77\":1}}],[\"遇到了js文件\",{\"1\":{\"76\":1}}],[\"才解析之后的html\",{\"1\":{\"76\":1}}],[\"才会执行js代码\",{\"1\":{\"75\":1}}],[\"获取了\",{\"1\":{\"84\":3}}],[\"获取不到box\",{\"1\":{\"76\":1}}],[\"获取vue这个全局对象的属性和方法\",{\"1\":{\"4\":1,\"88\":1}}],[\"直到解析完成\",{\"1\":{\"76\":1}}],[\"绿色部分代表的是正在解析html\",{\"1\":{\"76\":1}}],[\"什么延迟加载的方式都不加\",{\"0\":{\"76\":1}}],[\"什么是pipes\",{\"0\":{\"59\":1}}],[\"什么是redux\",{\"0\":{\"58\":1}}],[\"什么是viewencapsulation\",{\"0\":{\"49\":1}}],[\"什么是angular组件\",{\"0\":{\"15\":1}}],[\"谁先加载完谁先执行\",{\"1\":{\"75\":1}}],[\"顺次执行js脚本\",{\"1\":{\"75\":1}}],[\"延迟加载\",{\"1\":{\"75\":1}}],[\"延迟加载js有哪些方式\",{\"0\":{\"75\":1}}],[\"06\",{\"0\":{\"94\":1}}],[\"05\",{\"0\":{\"89\":1}}],[\"04\",{\"0\":{\"88\":1}}],[\"03\",{\"0\":{\"87\":1}}],[\"0\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"01\",{\"0\":{\"75\":1,\"80\":1}}],[\"02\",{\"0\":{\"5\":1,\"86\":1}}],[\"查询的元素\",{\"1\":{\"74\":2}}],[\"查找每个参数所对应的依赖项\",{\"1\":{\"26\":1}}],[\"|function|string\",{\"1\":{\"74\":1}}],[\"||\",{\"1\":{\"36\":1,\"37\":1}}],[\"都可以实现数据与页面实时更新\",{\"1\":{\"82\":1}}],[\"都支持\",{\"1\":{\"74\":1}}],[\"都有对应的复数形式装饰器\",{\"1\":{\"74\":1}}],[\"都是属性装饰器\",{\"1\":{\"74\":1}}],[\"都不一样\",{\"1\":{\"72\":1}}],[\"相同点\",{\"1\":{\"74\":1}}],[\"相比之下\",{\"1\":{\"14\":1}}],[\"与new\",{\"0\":{\"84\":1}}],[\"与\",{\"0\":{\"74\":1}}],[\"与html标签一起使用\",{\"1\":{\"51\":1}}],[\"易于单元测试\",{\"1\":{\"73\":1}}],[\"把验证逻辑抽离到组件类中\",{\"1\":{\"73\":1}}],[\"把应用划分成细小的可重复利用的组件\",{\"1\":{\"46\":1}}],[\"实现数据双向绑定\",{\"1\":{\"73\":1}}],[\"适用于复杂的场景\",{\"1\":{\"73\":1}}],[\"适用于简单的场景\",{\"1\":{\"73\":1}}],[\"适合于更复杂的场景\",{\"1\":{\"37\":1}}],[\"列举一下angular中的filter类型\",{\"0\":{\"70\":1}}],[\"支持依赖注入\",{\"1\":{\"68\":1}}],[\"支持双向数据绑定\",{\"1\":{\"68\":1}}],[\"强大的功能比如动画和事件处理\",{\"1\":{\"68\":1}}],[\"优秀的社区支持\",{\"1\":{\"68\":1}}],[\"优势\",{\"0\":{\"13\":1}}],[\"所有dependencies\",{\"1\":{\"67\":1}}],[\"所以需要sum\",{\"1\":{\"90\":1}}],[\"所以打印的结果为null\",{\"1\":{\"76\":1}}],[\"所以可以使用懒加载\",{\"1\":{\"66\":1}}],[\"所以可以在index\",{\"1\":{\"63\":1}}],[\"所以既然ngonchanges是输入属性发生变化的时候调用\",{\"1\":{\"65\":1}}],[\"所以从angular的生命周期看\",{\"1\":{\"65\":1}}],[\"所以这个目录就是根目录\",{\"1\":{\"63\":1}}],[\"所以数据的赋值就要在nexttick进行\",{\"1\":{\"4\":1,\"88\":1}}],[\"所以是异步执行的\",{\"1\":{\"4\":1,\"88\":1}}],[\"所以使用\",{\"1\":{\"4\":1,\"88\":1}}],[\"确保应用中已经移除了不使用的第三方库\",{\"1\":{\"67\":1}}],[\"确保应用程序不存在不必要的import语句\",{\"1\":{\"67\":1}}],[\"确保应用程序已经经过了捆绑\",{\"1\":{\"67\":1}}],[\"确保应用的性能和稳定性\",{\"1\":{\"40\":1}}],[\"考虑aot编译\",{\"1\":{\"67\":1}}],[\"知识点\",{\"1\":{\"66\":1}}],[\"子模块不加载\",{\"1\":{\"66\":1}}],[\"子组件传值给父组件\",{\"1\":{\"44\":1}}],[\"子组件中使用事件发射器\",{\"1\":{\"44\":1}}],[\"子组件中使用\",{\"1\":{\"44\":2}}],[\"子组件使用setup的形式\",{\"1\":{\"4\":1,\"88\":1}}],[\"启动速度慢\",{\"1\":{\"66\":1}}],[\"启动angular\",{\"1\":{\"57\":1}}],[\"变量初始化等\",{\"1\":{\"65\":1}}],[\"第一次显示数据绑定和设置指令\",{\"1\":{\"65\":1}}],[\"第一次调用ngdocheck\",{\"1\":{\"42\":1}}],[\"构造函数会被调用\",{\"1\":{\"65\":1}}],[\"构建\",{\"1\":{\"13\":1}}],[\"x\",{\"1\":{\"64\":2}}],[\"xxxxx\",{\"1\":{\"7\":1}}],[\"观察者用来接收可观察者发送过来的消息\",{\"1\":{\"64\":1}}],[\"观察者\",{\"1\":{\"64\":1}}],[\"函数\",{\"1\":{\"64\":1}}],[\"返回\",{\"1\":{\"64\":1}}],[\"包含next\",{\"1\":{\"64\":1}}],[\"包括当前值和上一个属性值\",{\"1\":{\"42\":1}}],[\"包括ngoninit\",{\"0\":{\"39\":1}}],[\"包括组件\",{\"1\":{\"12\":1}}],[\"接受一个observer对象\",{\"1\":{\"64\":1}}],[\"接受一个observer作为参数然后返回unsubscribe函数\",{\"1\":{\"64\":1}}],[\"接下来\",{\"1\":{\"17\":1}}],[\"加载应用会失败\",{\"1\":{\"63\":1}}],[\"加载css类\",{\"1\":{\"60\":1}}],[\"开发期间\",{\"1\":{\"63\":1}}],[\"开发者能够更好地控制组件的行为\",{\"1\":{\"40\":1}}],[\"作用\",{\"1\":{\"64\":1}}],[\"作用域隔离\",{\"1\":{\"19\":1}}],[\"作用域\",{\"1\":{\"4\":1,\"88\":1}}],[\"作为生产者和观察者之间的桥梁\",{\"1\":{\"64\":1}}],[\"作为参数\",{\"1\":{\"64\":1}}],[\"作为组件\",{\"1\":{\"63\":1}}],[\"设置了\",{\"1\":{\"84\":3}}],[\"设置的视图中获取匹配的元素\",{\"1\":{\"74\":1}}],[\"设置base\",{\"0\":{\"63\":1}}],[\"设置css样式\",{\"1\":{\"60\":1}}],[\"怎样在组件中选择一个元素\",{\"0\":{\"62\":1}}],[\"除非确实有动态组件的需求\",{\"1\":{\"57\":1}}],[\"除非明确地导出或引入\",{\"1\":{\"19\":1}}],[\"编译时间短\",{\"1\":{\"57\":1}}],[\"渲染得更快\",{\"1\":{\"57\":1}}],[\"渲染页面\",{\"1\":{\"57\":1}}],[\"页面渲染\",{\"1\":{\"57\":1}}],[\"页面占位符\",{\"1\":{\"50\":1}}],[\"下载代码\",{\"1\":{\"57\":1}}],[\"流程\",{\"1\":{\"57\":1}}],[\"浏览器下载js代码\",{\"1\":{\"57\":1}}],[\"部署好之后\",{\"1\":{\"57\":1}}],[\"部署\",{\"1\":{\"57\":1}}],[\"压缩\",{\"1\":{\"57\":1}}],[\"大概的开发流程\",{\"1\":{\"57\":1}}],[\"生成typescript代码\",{\"1\":{\"57\":1}}],[\"生成的是ts代码\",{\"1\":{\"57\":1}}],[\"生成的js代码\",{\"1\":{\"57\":1}}],[\"生命周期的顺序\",{\"1\":{\"42\":1}}],[\"生命周期钩子中才能成功获取通过\",{\"1\":{\"74\":2}}],[\"生命周期钩子\",{\"0\":{\"42\":1}}],[\"她被授权访问某些数据\",{\"1\":{\"56\":1}}],[\"他是等某个js谁先解析完谁先执行\",{\"1\":{\"79\":1}}],[\"他们会存在并行解析\",{\"1\":{\"77\":1}}],[\"他会暂停解析html\",{\"1\":{\"76\":1}}],[\"他\",{\"1\":{\"56\":1}}],[\"经过身份验证或真正的用户不能访问所有内容\",{\"1\":{\"56\":1}}],[\"登录成功后\",{\"1\":{\"56\":1}}],[\"授权\",{\"1\":{\"56\":1}}],[\"java\",{\"0\":{\"102\":1}}],[\"javascript\",{\"1\":{\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"84\":2}}],[\"jit优势\",{\"1\":{\"57\":1}}],[\"jit\",{\"1\":{\"57\":1}}],[\"just\",{\"1\":{\"57\":1}}],[\"jwt是一个json对象\",{\"1\":{\"56\":1}}],[\"jwt\",{\"1\":{\"56\":1}}],[\"js1必须放在js2上面\",{\"1\":{\"79\":1}}],[\"js\",{\"1\":{\"75\":2,\"76\":1,\"77\":1,\"78\":1}}],[\"json\",{\"1\":{\"70\":1}}],[\"jsp\",{\"1\":{\"53\":1}}],[\"js和react等其他框架支持一种称为\",{\"1\":{\"14\":1}}],[\"js中获取应用实例\",{\"0\":{\"7\":1}}],[\"稍后\",{\"1\":{\"55\":1}}],[\"就用新的数据更新现有的视图\",{\"1\":{\"71\":1}}],[\"就会执行\",{\"1\":{\"54\":1}}],[\"就是把dom要更新\",{\"1\":{\"4\":1,\"88\":1}}],[\"就是函数式\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"意思是一旦创建\",{\"1\":{\"54\":1}}],[\"意思是在subsciption之前什么都不会发生\",{\"1\":{\"54\":1}}],[\"或者多个事件\",{\"1\":{\"54\":1}}],[\"或者是重新加载使用了大量时间\",{\"1\":{\"53\":1}}],[\"或html页面\",{\"1\":{\"53\":1}}],[\"响应中消耗了大量时间\",{\"1\":{\"53\":1}}],[\"响应式表单的比较\",{\"0\":{\"73\":1}}],[\"响应式表单会更适合\",{\"1\":{\"38\":1}}],[\"响应式表单使得代码更加模块化和易于测试\",{\"1\":{\"38\":1}}],[\"响应式表单提供了更多的控制权\",{\"1\":{\"38\":1}}],[\"响应式表单允许开发者拥有对表单控件状态和验证过程的完全控制\",{\"1\":{\"37\":1}}],[\"响应式表单是一种更灵活和可扩展的表单处理方式\",{\"1\":{\"37\":1}}],[\"响应式表单\",{\"0\":{\"37\":1},\"1\":{\"73\":1}}],[\"响应式编程\",{\"1\":{\"12\":1}}],[\"客户端和服务器的通讯非常便利\",{\"1\":{\"68\":1}}],[\"客户端或用户将被该jwt所标记\",{\"1\":{\"56\":1}}],[\"客户端再次请求另一个页面\",{\"1\":{\"53\":1}}],[\"客户端请求一个web页面\",{\"1\":{\"53\":1}}],[\"中不适合进行任何和组件通信类似的复杂操作\",{\"1\":{\"65\":1}}],[\"中的值\",{\"1\":{\"51\":1}}],[\"中导航不同的视图或组件\",{\"1\":{\"32\":1}}],[\"数据更新了\",{\"1\":{\"83\":1}}],[\"数据更新了视图没更新\",{\"1\":{\"83\":2}}],[\"数据引用\",{\"0\":{\"51\":1}}],[\"数据绑定\",{\"1\":{\"45\":2,\"69\":1}}],[\"决定component显示在哪里\",{\"1\":{\"50\":1}}],[\"决定组件中定义的样式是否会影响整个应用程序\",{\"1\":{\"49\":1}}],[\"简单的数据流应用程序不需要redux\",{\"1\":{\"58\":1}}],[\"简单理解\",{\"1\":{\"50\":1}}],[\"简化了html模板的代码\",{\"1\":{\"73\":1}}],[\"简化了开发过程\",{\"1\":{\"14\":1}}],[\"简化异步处理\",{\"1\":{\"12\":1}}],[\"来初始化操作\",{\"1\":{\"65\":1}}],[\"来操作dom元素\",{\"1\":{\"62\":1}}],[\"来自其他html的样式不会传播到组件\",{\"1\":{\"49\":1}}],[\"来定义数据的和vue2的data类似\",{\"1\":{\"4\":1,\"88\":1}}],[\"样式从其他html传播到组件\",{\"1\":{\"49\":1}}],[\"像p标签或者h1标签\",{\"1\":{\"47\":1}}],[\"+\",{\"1\":{\"45\":1,\"64\":2}}],[\"主动获取子组件的数据和方法\",{\"1\":{\"44\":1}}],[\"主要让功能模块细分\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"父子组件之间的数据传递\",{\"0\":{\"44\":1}}],[\"父组件中使用\",{\"1\":{\"44\":1}}],[\"父组件向子组件传递数据和传递方法\",{\"1\":{\"44\":1}}],[\"父组件通过属性\",{\"1\":{\"14\":1}}],[\"父组件传递的值\",{\"1\":{\"4\":1,\"88\":1}}],[\"继承于directive类\",{\"1\":{\"43\":1}}],[\"退订可观察对象\",{\"1\":{\"42\":1}}],[\"初始化指令\",{\"1\":{\"65\":1}}],[\"初始化指令或组件\",{\"1\":{\"42\":1}}],[\"初始化完组件视图及其子视图或包含该指令的视图之后调用\",{\"1\":{\"42\":1}}],[\"之后调用\",{\"1\":{\"42\":1}}],[\"之间自动同步的技术\",{\"1\":{\"14\":1}}],[\"无法或不愿意自己检测的变化时作出反应\",{\"1\":{\"42\":1}}],[\"检测\",{\"1\":{\"42\":1}}],[\"值得注意的是该方法仅限于对象的引用发生变化时才会触发\",{\"1\":{\"42\":1}}],[\"首次调用一定发生在ngoninit前\",{\"1\":{\"42\":1}}],[\"首先\",{\"1\":{\"26\":1,\"33\":1}}],[\"首先需要将其声明在某个模块中\",{\"1\":{\"17\":1}}],[\"首先在index\",{\"0\":{\"7\":1}}],[\"用来从模板视图中获取匹配的元素\",{\"1\":{\"74\":1}}],[\"用来从通过\",{\"1\":{\"74\":1}}],[\"用来初始化组件\",{\"1\":{\"65\":1}}],[\"用angular编译器对模板进行编译\",{\"1\":{\"57\":1}}],[\"用ngc编译\",{\"1\":{\"57\":1}}],[\"用户端\",{\"1\":{\"57\":1}}],[\"用户在浏览器端\",{\"1\":{\"57\":1}}],[\"用户未被授权访问其他人的数据\",{\"1\":{\"56\":1}}],[\"用户登录凭据传递给\",{\"1\":{\"56\":1}}],[\"用途\",{\"1\":{\"42\":1}}],[\"用于子模块\",{\"1\":{\"66\":1}}],[\"用于主模块\",{\"1\":{\"66\":1}}],[\"用于取消订阅\",{\"1\":{\"64\":1}}],[\"用于动态添加或删除dom元素来改变dom布局\",{\"1\":{\"43\":1}}],[\"用于改变组件的外观或行为\",{\"1\":{\"43\":1}}],[\"用于构建ui组件\",{\"1\":{\"43\":1}}],[\"用于构建高效\",{\"1\":{\"11\":1}}],[\"用于封装应用程序中的业务逻辑和数据\",{\"1\":{\"22\":1}}],[\"用于告诉angular如何处理这个组件\",{\"1\":{\"16\":1}}],[\"用于描述组件的视图结构和布局\",{\"1\":{\"16\":1}}],[\"用于展示用户界面\",{\"1\":{\"15\":1}}],[\"钩子方法\",{\"1\":{\"42\":1}}],[\"见下图\",{\"1\":{\"42\":1}}],[\"​\",{\"1\":{\"40\":1,\"54\":3,\"57\":26,\"64\":6}}],[\"​\\t\",{\"1\":{\"9\":1}}],[\"只适用于组件\",{\"1\":{\"42\":3}}],[\"只调用一次\",{\"1\":{\"42\":1}}],[\"只有在输入属性发生变化时才会被调用\",{\"1\":{\"40\":1}}],[\"只需在html元素上添加\",{\"1\":{\"31\":1}}],[\"只需在html元素上添加apphighlight属性即可\",{\"1\":{\"30\":1}}],[\"注意\",{\"1\":{\"40\":1}}],[\"执行顺序\",{\"0\":{\"40\":1}}],[\"执行清理任务等\",{\"1\":{\"39\":1}}],[\"释放定时器等\",{\"1\":{\"39\":1}}],[\"此功能用于更改模板上的输出\",{\"1\":{\"59\":1}}],[\"此方法可以用来实现自定义变更检测逻辑\",{\"1\":{\"39\":1}}],[\"此时所有的输入属性已经被设置\",{\"1\":{\"39\":1}}],[\"每次做完组件视图和子视图的变更检测之后调用\",{\"1\":{\"42\":1}}],[\"每次完成被投影组件内容的变更检测之后调用\",{\"1\":{\"42\":1}}],[\"每次变更检测周期时都会调用\",{\"1\":{\"39\":1}}],[\"每个服务在应用中只创建一个实例\",{\"1\":{\"24\":1}}],[\"每个组件通常包含三个主要部分\",{\"1\":{\"15\":1}}],[\"每个组件可以有自己的html模板\",{\"1\":{\"12\":1}}],[\"你可以访问到通过内容投影传入的元素和指令\",{\"1\":{\"39\":1}}],[\"你们vue3写代码的方式\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"完成后调用\",{\"1\":{\"39\":1}}],[\"比较灵活\",{\"1\":{\"73\":1}}],[\"比较乱\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"比如依赖注入\",{\"1\":{\"65\":1}}],[\"比如将字符串更改为大写并在模板上显示它\",{\"1\":{\"59\":1}}],[\"比如使用懒加载\",{\"1\":{\"40\":1}}],[\"比如获取数据或设置订阅\",{\"1\":{\"39\":1}}],[\"该方法只会调用一次\",{\"1\":{\"42\":1}}],[\"该方法接收一个simplechanges对象\",{\"1\":{\"42\":1}}],[\"该对象包含了所有发生改变的输入属性以及它们的新旧值\",{\"1\":{\"39\":1}}],[\"该属性被用于模板中的插值表达式\",{\"1\":{\"29\":1}}],[\"订阅事件\",{\"1\":{\"39\":1}}],[\"选择使用哪种类型的表单取决于具体的应用需求和个人喜好\",{\"1\":{\"38\":1}}],[\"选项式api\",{\"1\":{\"3\":1,\"85\":1}}],[\"学习曲线\",{\"1\":{\"38\":1}}],[\"代码示例及效果演示\",{\"0\":{\"95\":1}}],[\"代码示例\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"代码结构\",{\"1\":{\"38\":1}}],[\"代码==\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"删除或修改表单控件\",{\"1\":{\"38\":1}}],[\"灵活性\",{\"1\":{\"38\":1}}],[\"区别和用法\",{\"0\":{\"38\":1}}],[\"路径\",{\"1\":{\"34\":1}}],[\"路由\",{\"1\":{\"69\":1}}],[\"路由跳转等\",{\"1\":{\"40\":1}}],[\"路由是什么\",{\"0\":{\"33\":1}}],[\"路由与导航\",{\"1\":{\"12\":1}}],[\"另一个是\",{\"1\":{\"34\":1}}],[\"对各个浏览器来说都是有自己具体的实现\",{\"1\":{\"72\":1}}],[\"对象\",{\"1\":{\"64\":1}}],[\"对于初学者来说\",{\"1\":{\"38\":1}}],[\"对于大型应用程序\",{\"1\":{\"33\":1}}],[\"对应于aboutcomponent\",{\"1\":{\"34\":1}}],[\"对应于homecomponent\",{\"1\":{\"34\":1}}],[\"展示了如何在angular应用中配置和使用路由\",{\"1\":{\"34\":1}}],[\"展示了如何在组件中使用依赖注入\",{\"1\":{\"27\":1}}],[\"懒加载\",{\"1\":{\"33\":1,\"66\":1}}],[\"导致js报错\",{\"1\":{\"79\":1}}],[\"导致加载缓慢\",{\"1\":{\"66\":1}}],[\"导航\",{\"1\":{\"33\":1}}],[\"导入自定义模块\",{\"1\":{\"21\":1}}],[\"导入通用模块以获取常用指令等\",{\"1\":{\"20\":1}}],[\"配置位置\",{\"1\":{\"38\":1}}],[\"配置\",{\"1\":{\"33\":1}}],[\"允许用户在单页面应用\",{\"1\":{\"32\":1}}],[\"隐藏元素和循环遍历数组\",{\"1\":{\"31\":1}}],[\"分别用于根据条件显示\",{\"1\":{\"31\":1}}],[\"分为\",{\"1\":{\"4\":1,\"88\":1}}],[\"移除或重复dom元素来改变视图的结构\",{\"1\":{\"31\":1}}],[\"结构指令用于修改dom的布局\",{\"1\":{\"31\":1}}],[\"结构指令\",{\"0\":{\"31\":1},\"1\":{\"43\":1}}],[\"yellow\",{\"1\":{\"30\":1}}],[\"事件绑定\",{\"1\":{\"45\":2,\"52\":1}}],[\"事件传递的方式\",{\"1\":{\"44\":1}}],[\"事件处理等方式与其他组件通信\",{\"1\":{\"29\":1}}],[\"事件和输入\",{\"1\":{\"14\":1}}],[\"而在vue2中\",{\"1\":{\"83\":1}}],[\"而在spa技术中\",{\"1\":{\"53\":1}}],[\"而async不按顺次执行\",{\"1\":{\"79\":1}}],[\"而且defer去执行js时\",{\"1\":{\"79\":1}}],[\"而constructor是在组件实例化的时候就调用了\",{\"1\":{\"65\":1}}],[\"而不需要临时属性\",{\"1\":{\"55\":1}}],[\"而不会影响其结构\",{\"1\":{\"30\":1}}],[\"而directive没有\",{\"1\":{\"46\":1}}],[\"而directive用来在已经存在的dom元素上实现一些行为\",{\"1\":{\"46\":1}}],[\"而响应式表单需要更多的时间和经验才能熟练掌握\",{\"1\":{\"38\":1}}],[\"而响应式表单的配置则是在组件类中完成\",{\"1\":{\"38\":1}}],[\"而模板驱动表单的验证逻辑分散在模板和组件之间\",{\"1\":{\"38\":1}}],[\"而模板驱动表单在这方面相对较弱\",{\"1\":{\"38\":1}}],[\"而router\",{\"1\":{\"34\":1}}],[\"而无需重新加载整个页面\",{\"1\":{\"32\":1}}],[\"而无需修改依赖它们的组件或服务\",{\"1\":{\"27\":1}}],[\"而子组件不能直接修改这些数据\",{\"1\":{\"14\":1}}],[\"找到dataservice提供者后\",{\"1\":{\"27\":1}}],[\"如异步请求等\",{\"1\":{\"65\":1}}],[\"如初始化数据\",{\"1\":{\"39\":1}}],[\"如下所示\",{\"1\":{\"34\":1}}],[\"如何配置和使用路由\",{\"0\":{\"34\":1}}],[\"如何使用依赖注入\",{\"0\":{\"27\":1}}],[\"如果项目中使用defer解析js时\",{\"1\":{\"79\":1}}],[\"如果看到有改变\",{\"1\":{\"71\":1}}],[\"如果应用程序较大时\",{\"1\":{\"67\":1}}],[\"如果应用程序的表单需求相对简单\",{\"1\":{\"38\":1}}],[\"如果需要更高级的功能或者更好的代码组织结构\",{\"1\":{\"38\":1}}],[\"如果找到匹配的依赖项\",{\"1\":{\"26\":1}}],[\"如果子组件需要更新数据\",{\"1\":{\"14\":1}}],[\"如果层级过多传递麻烦\",{\"1\":{\"4\":1,\"88\":1}}],[\"如果大家还知道其他api不同点\",{\"1\":{\"3\":1}}],[\"有几种数据绑定方式\",{\"0\":{\"52\":1}}],[\"有哪些不同的类型\",{\"0\":{\"28\":1}}],[\"有助于保持项目的整洁和模块化\",{\"1\":{\"24\":1}}],[\"有缓存\",{\"1\":{\"4\":1,\"88\":1}}],[\"更适合于不需要等待页面完整加载即可运行的第三方脚本\",{\"1\":{\"79\":1}}],[\"更安全\",{\"1\":{\"57\":1}}],[\"更好的组织结构\",{\"1\":{\"24\":1}}],[\"更新刷新的工具方法\",{\"1\":{\"4\":1,\"88\":1}}],[\"默认情况下\",{\"1\":{\"24\":1,\"66\":1}}],[\"单页面应用和传统的web技术有什么不同\",{\"0\":{\"53\":1}}],[\"单例模式\",{\"1\":{\"24\":1}}],[\"单向数据流\",{\"1\":{\"14\":1}}],[\"因为是要改变sum的值\",{\"1\":{\"90\":1}}],[\"因为它提供了更高的灵活性\",{\"1\":{\"79\":1}}],[\"因为所有表单逻辑都在组件类中\",{\"1\":{\"38\":1}}],[\"因为我们可以轻松地替换掉依赖项的实现\",{\"1\":{\"27\":1}}],[\"因为new\",{\"1\":{\"3\":1,\"85\":1}}],[\"因此更容易进行单元测试\",{\"1\":{\"24\":1}}],[\"由此\",{\"1\":{\"83\":1}}],[\"由此可见\",{\"1\":{\"82\":1,\"83\":1}}],[\"由于服务通常不涉及ui相关的内容\",{\"1\":{\"24\":1}}],[\"由父组件来做出相应的数据更改\",{\"1\":{\"14\":1}}],[\"从而降低了组件间的耦合度\",{\"1\":{\"24\":1}}],[\"将相关的数据和逻辑放入服务中\",{\"1\":{\"24\":1}}],[\"将通用的逻辑放在服务中\",{\"1\":{\"24\":1}}],[\"将数据传给子组件\",{\"1\":{\"14\":1}}],[\"复用性\",{\"1\":{\"24\":1}}],[\"复杂类型\",{\"0\":{\"91\":1},\"1\":{\"4\":1}}],[\"为什么使用服务来共享数据和逻辑\",{\"0\":{\"24\":1}}],[\"避免了代码重复和维护复杂性\",{\"1\":{\"23\":1}}],[\"跨组件共享\",{\"1\":{\"23\":1}}],[\"跨平台能力\",{\"1\":{\"13\":1}}],[\"状态管理等\",{\"1\":{\"23\":1}}],[\"认证api\",{\"1\":{\"56\":1}}],[\"认证\",{\"1\":{\"23\":1,\"56\":1}}],[\"服务\",{\"1\":{\"69\":1}}],[\"服务器上的\",{\"1\":{\"56\":1}}],[\"服务器用另一个资源响应\",{\"1\":{\"53\":1}}],[\"服务器返回资源\",{\"1\":{\"53\":1}}],[\"服务允许在多个组件间共享相同的逻辑和数据\",{\"1\":{\"23\":1}}],[\"服务可以包含与特定功能相关的业务逻辑\",{\"1\":{\"23\":1}}],[\"服务是什么\",{\"0\":{\"23\":1}}],[\"封装逻辑\",{\"1\":{\"23\":1}}],[\"封装全局组件会使用\",{\"1\":{\"4\":1,\"88\":1}}],[\"系统注册和管理的\",{\"1\":{\"23\":1}}],[\"处理数据和执行通用任务的有效方式\",{\"1\":{\"22\":1}}],[\"处理事件\",{\"1\":{\"16\":1}}],[\"现在\",{\"1\":{\"21\":1}}],[\"假设我们有一个根模块appmodule\",{\"1\":{\"21\":1}}],[\"假如自己写弹出框\",{\"1\":{\"4\":1,\"97\":1}}],[\"最小化组件类的代码\",{\"1\":{\"73\":1}}],[\"最终会被相应的component的view替换掉\",{\"1\":{\"50\":1}}],[\"最终的结果是在浏览器中显示一个蓝色的标题\",{\"1\":{\"17\":1}}],[\"最后在开始解析html\",{\"1\":{\"76\":1}}],[\"最后\",{\"1\":{\"20\":1,\"27\":1,\"34\":1}}],[\"并去解析js\",{\"1\":{\"76\":1}}],[\"并返回一种方法来解除生产者和观察者之间的关系\",{\"1\":{\"64\":1}}],[\"并在发生\",{\"1\":{\"42\":1}}],[\"并且ngoninit是在ngonchanges执行之后才调用\",{\"1\":{\"65\":1}}],[\"并且为每个事件回调\",{\"1\":{\"54\":1}}],[\"并且视图已经初始化完成\",{\"1\":{\"39\":1}}],[\"并且可以通过属性绑定\",{\"1\":{\"29\":1}}],[\"并通过内置的指令如ngrequired\",{\"1\":{\"36\":1}}],[\"并将我们的路由配置传递给forroot\",{\"1\":{\"34\":1}}],[\"并将其注入到appcomponent的构造函数中\",{\"1\":{\"27\":1}}],[\"并将其注册到依赖注入容器中\",{\"1\":{\"26\":1}}],[\"并为用户提供更流畅的用户体验\",{\"1\":{\"32\":1}}],[\"并查找是否已经注册了dataservice提供者\",{\"1\":{\"27\":1}}],[\"并促进了代码的可重用性和可维护性\",{\"1\":{\"24\":1}}],[\"并导入了commonmodule以获取常用的指令和管道\",{\"1\":{\"20\":1}}],[\"并于2016年进行了重写并改名为angular\",{\"1\":{\"11\":1}}],[\"我会考虑延迟加载而不是完全捆绑的应用程序\",{\"1\":{\"67\":1}}],[\"我们将相同的内容绑定到模板\",{\"1\":{\"55\":1}}],[\"我们将approutingmodule导出\",{\"1\":{\"34\":1}}],[\"我们使用一个临时属性来保存内容\",{\"1\":{\"55\":1}}],[\"我们使用了formgroup和formcontrol来自定义表单模型\",{\"1\":{\"37\":1}}],[\"我们使用了\",{\"1\":{\"36\":1}}],[\"我们也只维护一个页面\",{\"1\":{\"53\":1}}],[\"我们也可以在服务中使用依赖注入来访问其他服务或资源\",{\"1\":{\"27\":1}}],[\"我们可以知道\",{\"1\":{\"83\":1}}],[\"我们可以轻松地在angular应用中实现单页面应用的路由功能\",{\"1\":{\"34\":1}}],[\"我们可以使用routerlink指令\",{\"1\":{\"34\":1}}],[\"我们可以在应用程序中使用路由器来导航到这些路径\",{\"1\":{\"33\":1}}],[\"我们可以这样做\",{\"1\":{\"21\":1}}],[\"我们需要定义一个路由配置对象\",{\"1\":{\"33\":1}}],[\"我们需要定义服务\",{\"1\":{\"26\":1}}],[\"我们创建了一个名为approutingmodule的模块\",{\"1\":{\"34\":1}}],[\"我们创建了一个名为routes的对象数组\",{\"1\":{\"34\":1}}],[\"我们创建了一个名为unlessdirective的结构指令\",{\"1\":{\"31\":1}}],[\"我们创建了一个名为highlightdirective的属性指令\",{\"1\":{\"30\":1}}],[\"我们创建了一个名为helloworldcomponent的组件\",{\"1\":{\"29\":1}}],[\"我们创建了一个名为mymodule的新模块\",{\"1\":{\"20\":1}}],[\"我们在组件类中使用dataservice来获取数据并显示在视图中\",{\"1\":{\"27\":1}}],[\"我们在declarations数组中声明了我们自定义的组件\",{\"1\":{\"20\":1}}],[\"我们声明了一个名为dataservice的参数\",{\"1\":{\"27\":1}}],[\"我们有一个名为appcomponent的组件\",{\"1\":{\"27\":1}}],[\"我们通过构造函数参数来表示需要依赖的服务或其他资源\",{\"1\":{\"26\":1}}],[\"我们想在其中使用上面定义的mymodule\",{\"1\":{\"21\":1}}],[\"我们指定了允许外部模块访问的组件\",{\"1\":{\"20\":1}}],[\"我在小程序的分享功能会用到\",{\"1\":{\"4\":1,\"88\":1}}],[\"定义哪些组件\",{\"1\":{\"20\":1}}],[\"定义模块\",{\"0\":{\"20\":1}}],[\"声明模块内部使用的组件\",{\"1\":{\"20\":1}}],[\"装饰器来完成\",{\"1\":{\"26\":1}}],[\"装饰器\",{\"1\":{\"20\":1}}],[\"装饰器包含了组件的模板和样式表等信息\",{\"1\":{\"16\":1}}],[\"要在html模板中使用路由\",{\"1\":{\"34\":1}}],[\"要使用这个指令\",{\"1\":{\"30\":1,\"31\":1}}],[\"要使用这个组件\",{\"1\":{\"17\":1}}],[\"要使用一个模块\",{\"1\":{\"21\":1}}],[\"要定义一个angular模块\",{\"1\":{\"20\":1}}],[\"通俗\",{\"1\":{\"66\":1}}],[\"通常会在index\",{\"1\":{\"63\":1}}],[\"通常用于移除事件监听\",{\"1\":{\"42\":1}}],[\"通过\",{\"1\":{\"73\":1}}],[\"通过对应的api来访问里面的数据\",{\"1\":{\"72\":1}}],[\"通过使用asyncpipe\",{\"1\":{\"55\":1}}],[\"通过使用路由\",{\"1\":{\"32\":1}}],[\"通过理解并有效利用这些生命周期钩子函数\",{\"1\":{\"40\":1}}],[\"通过这种方式\",{\"1\":{\"34\":1}}],[\"通过添加\",{\"1\":{\"31\":1}}],[\"通过服务来处理数据和逻辑\",{\"1\":{\"24\":1}}],[\"通过声明依赖关系\",{\"1\":{\"19\":1}}],[\"通知父组件\",{\"1\":{\"14\":1}}],[\"依赖解析\",{\"1\":{\"26\":1}}],[\"依赖声明\",{\"1\":{\"26\":1}}],[\"依赖管理\",{\"1\":{\"19\":1}}],[\"依赖注入了哪些类\",{\"1\":{\"61\":1}}],[\"依赖注入是什么\",{\"0\":{\"26\":1}}],[\"依赖注入系统自动管理对象的生命周期和依赖关系\",{\"1\":{\"25\":1}}],[\"依赖注入\",{\"1\":{\"4\":1,\"12\":1,\"69\":1,\"88\":1}}],[\"组织和封装\",{\"1\":{\"19\":1}}],[\"组件b代码\",{\"1\":{\"95\":1}}],[\"组件a代码\",{\"1\":{\"95\":1}}],[\"组件不使用\",{\"0\":{\"95\":1}}],[\"组件之间以及组件和service之间互相交互给app提供功能\",{\"1\":{\"61\":1}}],[\"组件中定义的样式对所有组件都是可见的\",{\"1\":{\"49\":1}}],[\"组件和指令的区别\",{\"0\":{\"46\":1}}],[\"组件的输入属性之后\",{\"1\":{\"65\":1}}],[\"组件的生命周期钩子函数执行顺序可能会因为不同的情况而有所变化\",{\"1\":{\"40\":1}}],[\"组件的内容投影被检查后调用\",{\"1\":{\"39\":1}}],[\"组件及其所有子视图被检查后调用\",{\"1\":{\"39\":1}}],[\"组件可以嵌套在其他组件中\",{\"1\":{\"29\":1}}],[\"组件是angular应用中最常见的指令类型\",{\"1\":{\"29\":1}}],[\"组件\",{\"0\":{\"29\":1},\"1\":{\"28\":1,\"43\":1,\"65\":1,\"69\":1}}],[\"组件用法\",{\"0\":{\"17\":1}}],[\"组件结构\",{\"0\":{\"16\":1}}],[\"组件化\",{\"1\":{\"12\":1}}],[\"管道和服务\",{\"1\":{\"18\":1}}],[\"管道和其他依赖项\",{\"1\":{\"12\":1}}],[\"是顺次执行\",{\"1\":{\"79\":1}}],[\"是window\",{\"1\":{\"72\":1}}],[\"是angular中oninit钩子的实现\",{\"1\":{\"65\":1}}],[\"是惰性的\",{\"1\":{\"54\":1}}],[\"是来自于ts\",{\"1\":{\"51\":1}}],[\"是一个函数\",{\"1\":{\"64\":1}}],[\"是一个可注入的类\",{\"1\":{\"22\":1}}],[\"是一种机制\",{\"1\":{\"32\":1}}],[\"是一种设计模式\",{\"1\":{\"25\":1}}],[\"是组织和打包应用程序代码的主要方式\",{\"1\":{\"18\":1}}],[\"是什么\",{\"0\":{\"18\":1,\"22\":1,\"25\":1,\"32\":1}}],[\"其中观察者用于处理时间序列上的数据流\",{\"1\":{\"64\":1}}],[\"其中包含了两个路由配置项\",{\"1\":{\"34\":1}}],[\"其中包含字符串\",{\"1\":{\"17\":1}}],[\"其配置和使用通常较为直观\",{\"1\":{\"36\":1}}],[\"其实就是传值\",{\"1\":{\"4\":1,\"88\":1}}],[\"表示应用程序的根元素\",{\"1\":{\"17\":1}}],[\"routeroutlet\",{\"0\":{\"50\":1}}],[\"routerlink指令将链接映射到相应的路由路径\",{\"1\":{\"34\":1}}],[\"routerlink=\",{\"1\":{\"34\":2}}],[\"router\",{\"0\":{\"48\":1},\"1\":{\"34\":2,\"48\":1,\"50\":1}}],[\"routermodule\",{\"1\":{\"34\":3,\"66\":2}}],[\"routes\",{\"1\":{\"34\":4,\"66\":2}}],[\"routing\",{\"0\":{\"32\":1},\"1\":{\"32\":1,\"69\":1}}],[\"root\",{\"1\":{\"27\":1}}],[\"root>\",{\"1\":{\"17\":1}}],[\"root>标签\",{\"1\":{\"17\":1}}],[\"root><\",{\"1\":{\"17\":2}}],[\"relative\",{\"1\":{\"95\":1,\"96\":1}}],[\"red\",{\"1\":{\"95\":1}}],[\"redirectto\",{\"1\":{\"66\":1}}],[\"receiver\",{\"1\":{\"84\":4}}],[\"return\",{\"1\":{\"83\":2,\"84\":3}}],[\"restful\",{\"1\":{\"68\":1}}],[\"required\",{\"1\":{\"36\":2,\"37\":3}}],[\"required>\",{\"1\":{\"36\":1}}],[\"reflect\",{\"1\":{\"84\":2}}],[\"ref\",{\"0\":{\"90\":1},\"1\":{\"4\":2,\"88\":1,\"90\":2,\"93\":1,\"95\":2,\"96\":2}}],[\"reactive\",{\"0\":{\"91\":1},\"1\":{\"4\":2,\"35\":1,\"73\":1,\"82\":2,\"88\":1,\"91\":2,\"92\":1,\"93\":2}}],[\"background\",{\"1\":{\"95\":3,\"96\":2}}],[\"backgroundcolor\",{\"1\":{\"30\":3}}],[\"btn\",{\"1\":{\"90\":2,\"91\":2,\"92\":2,\"93\":2,\"95\":2,\"96\":2}}],[\"b\",{\"1\":{\"82\":2,\"83\":4,\"84\":2,\"95\":2}}],[\"binding\",{\"1\":{\"69\":1}}],[\"button>\",{\"1\":{\"36\":1,\"37\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"body\",{\"1\":{\"96\":1}}],[\"body>\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"box\",{\"1\":{\"76\":4,\"77\":4,\"78\":4,\"95\":2,\"96\":2}}],[\"bom\",{\"1\":{\"72\":1}}],[\"bom用来操作浏览器窗口\",{\"1\":{\"72\":1}}],[\"bom包含在全局的javascript对象里面\",{\"1\":{\"72\":1}}],[\"bom包含dom\",{\"1\":{\"72\":1}}],[\"bom是browser\",{\"1\":{\"72\":1}}],[\"boolean\",{\"1\":{\"31\":1}}],[\"bootstrap\",{\"1\":{\"17\":1,\"21\":1}}],[\"browser\",{\"1\":{\"17\":1,\"21\":1}}],[\"browsermodule\",{\"1\":{\"17\":2,\"21\":2}}],[\"blue\",{\"1\":{\"16\":1,\"95\":1,\"96\":1}}],[\"然后去执行js\",{\"1\":{\"76\":1}}],[\"然后\",{\"1\":{\"20\":1,\"26\":1,\"33\":1,\"34\":1}}],[\"然后在相应的html文件中使用组件的selector标签来插入组件\",{\"1\":{\"17\":1}}],[\"然而\",{\"1\":{\"14\":1}}],[\"number\",{\"1\":{\"70\":1}}],[\"not\",{\"1\":{\"98\":1}}],[\"notification\",{\"1\":{\"64\":1}}],[\"none\",{\"1\":{\"49\":1}}],[\"native\",{\"1\":{\"49\":1}}],[\"navigatethis\",{\"1\":{\"48\":1}}],[\"navigate\",{\"0\":{\"48\":1},\"1\":{\"48\":1}}],[\"nav>\",{\"1\":{\"34\":1}}],[\"name=\",{\"1\":{\"36\":2,\"76\":1,\"77\":1,\"78\":1}}],[\"name\",{\"1\":{\"16\":2,\"29\":2,\"36\":8,\"37\":8,\"48\":1,\"83\":2,\"91\":2,\"92\":5,\"93\":4}}],[\"ng\",{\"0\":{\"47\":1,\"60\":2},\"1\":{\"47\":1,\"60\":2,\"74\":1}}],[\"ngswitch\",{\"1\":{\"43\":1}}],[\"ngstyle\",{\"1\":{\"43\":1}}],[\"ngsubmit\",{\"1\":{\"36\":1,\"37\":1}}],[\"ngclass\",{\"1\":{\"43\":1}}],[\"ngdocheck\",{\"1\":{\"39\":1,\"40\":3,\"42\":1}}],[\"ngaftercontentchecked\",{\"1\":{\"39\":1,\"40\":2,\"42\":1}}],[\"ngaftercontentinit\",{\"1\":{\"39\":1,\"40\":1,\"42\":1,\"74\":1}}],[\"ngafterviewchecked\",{\"1\":{\"39\":1,\"40\":2,\"42\":1}}],[\"ngafterviewinit\",{\"1\":{\"39\":1,\"40\":1,\"42\":1,\"74\":1}}],[\"ngondestroy\",{\"1\":{\"39\":1,\"40\":1,\"42\":1}}],[\"ngoninit可以用来初始化组件之间通信的\",{\"1\":{\"65\":1}}],[\"ngoninit\",{\"0\":{\"65\":1},\"1\":{\"39\":1,\"40\":1,\"42\":1,\"65\":3}}],[\"ngonchanges\",{\"1\":{\"39\":1,\"40\":2,\"42\":1}}],[\"ngonchanges和ngondestroy等常用钩子函数的作用和执行顺序\",{\"0\":{\"39\":1}}],[\"ngfor\",{\"1\":{\"43\":1}}],[\"ngform\",{\"1\":{\"36\":2}}],[\"ngfor就是结构指令\",{\"1\":{\"31\":1}}],[\"ngmodel\",{\"1\":{\"36\":3,\"73\":1}}],[\"ngmodule\",{\"1\":{\"17\":2,\"20\":3,\"21\":2,\"34\":2}}],[\"ngminlength等进行简单的验证\",{\"1\":{\"36\":1}}],[\"ngif条件语句显示验证错误消息\",{\"1\":{\"36\":1}}],[\"ngif=\",{\"1\":{\"36\":2,\"37\":2}}],[\"ngif\",{\"1\":{\"31\":1,\"43\":1}}],[\"ngif和\",{\"1\":{\"31\":1}}],[\"next\",{\"1\":{\"64\":2}}],[\"nexttick返回一个pormise\",{\"1\":{\"4\":1,\"88\":1}}],[\"nexttick\",{\"1\":{\"4\":1,\"88\":1}}],[\"newload\",{\"1\":{\"66\":2}}],[\"new\",{\"1\":{\"3\":1,\"4\":1,\"44\":1,\"84\":2,\"85\":1,\"88\":1}}],[\"例如在<app\",{\"1\":{\"47\":1}}],[\"例如取消订阅\",{\"1\":{\"39\":1}}],[\"例如数据获取\",{\"1\":{\"23\":1}}],[\"例如\",{\"1\":{\"16\":1,\"21\":1,\"29\":1,\"30\":1,\"31\":1,\"75\":2}}],[\"元数据\",{\"1\":{\"16\":1,\"69\":1}}],[\"访问服务以及操作数据\",{\"1\":{\"16\":1}}],[\"负责处理组件的行为逻辑\",{\"1\":{\"16\":1}}],[\"属性即可\",{\"1\":{\"31\":1}}],[\"属性指令用于改变元素的外观或行为\",{\"1\":{\"30\":1}}],[\"属性指令\",{\"0\":{\"30\":1},\"1\":{\"28\":1,\"43\":1}}],[\"属性绑定\",{\"1\":{\"16\":1,\"52\":1}}],[\"属性来模拟双向数据绑定的效果\",{\"1\":{\"14\":1}}],[\"类型的选择器\",{\"1\":{\"74\":1}}],[\"类型为dataservice\",{\"1\":{\"27\":1}}],[\"类型安全\",{\"1\":{\"13\":1}}],[\"类helloworldcomponent包含了组件的数据和方法\",{\"1\":{\"16\":1}}],[\"类\",{\"1\":{\"15\":1,\"16\":1}}],[\"的比较\",{\"0\":{\"84\":1}}],[\"的异同点\",{\"0\":{\"74\":1}}],[\"的特点\",{\"1\":{\"73\":2}}],[\"的讲就是进入主模块之后\",{\"1\":{\"66\":1}}],[\"的本质区别\",{\"0\":{\"65\":1}}],[\"的顶部添加\",{\"1\":{\"63\":1}}],[\"的使用\",{\"0\":{\"48\":1}}],[\"的形式出现在元素上\",{\"1\":{\"30\":1}}],[\"的一部分\",{\"1\":{\"15\":1}}],[\"的概念\",{\"1\":{\"14\":1}}],[\"可见\",{\"1\":{\"76\":2,\"77\":2,\"78\":2}}],[\"可观察者\",{\"1\":{\"64\":1}}],[\"可测试和易于维护\",{\"1\":{\"25\":1}}],[\"可注入\",{\"1\":{\"23\":1}}],[\"可重用的代码单元\",{\"1\":{\"15\":1}}],[\"可以获取到box\",{\"1\":{\"77\":1}}],[\"可以添加自定义的directive\",{\"1\":{\"68\":1}}],[\"可以添加生命周期\",{\"1\":{\"4\":1,\"88\":1}}],[\"可以传递0\",{\"1\":{\"54\":1}}],[\"可以方便地动态添加\",{\"1\":{\"38\":1}}],[\"可以构建具有多个视图和页面的应用程序\",{\"1\":{\"32\":1}}],[\"可以使这些逻辑在整个应用中得到复用\",{\"1\":{\"24\":1}}],[\"可以把盒子传送到body中\",{\"1\":{\"4\":1,\"97\":1}}],[\"同时提供了类似双向数据绑定的便利性\",{\"1\":{\"14\":1}}],[\"同样地\",{\"1\":{\"14\":1,\"27\":1}}],[\"即可实现数据与试图更新\",{\"1\":{\"83\":1}}],[\"即使vue3中\",{\"1\":{\"82\":1}}],[\"即使url不断变化\",{\"1\":{\"53\":1}}],[\"即使后添加的也可以劫持到\",{\"1\":{\"3\":1,\"84\":1,\"85\":1}}],[\"即template或templateurl\",{\"1\":{\"46\":1}}],[\"即只在需要时才加载特定模块及其相关组件\",{\"1\":{\"33\":1}}],[\"即上面定义的helloworldcomponent\",{\"1\":{\"17\":1}}],[\"即通过输出\",{\"1\":{\"14\":1}}],[\"但vue对象中有c的数据\",{\"1\":{\"84\":1}}],[\"但试图未更新\",{\"1\":{\"83\":1}}],[\"但可能伴随着一定的执行时机的不确定性\",{\"1\":{\"79\":1}}],[\"但都能帮助我们有效地管理和验证用户输入\",{\"1\":{\"35\":1}}],[\"但条件取反\",{\"1\":{\"31\":1}}],[\"但angular也提供了一种变通的方法\",{\"1\":{\"14\":1}}],[\"但是只能查看和修改\",{\"1\":{\"4\":1,\"88\":1}}],[\"尽管vue\",{\"1\":{\"14\":1}}],[\"特征\",{\"1\":{\"64\":1}}],[\"特别是涉及到组件之间的通信时\",{\"1\":{\"14\":1}}],[\"特别是在表单控件中使用\",{\"1\":{\"14\":1}}],[\"特点\",{\"0\":{\"12\":1}}],[\"模版\",{\"1\":{\"69\":1}}],[\"模块\",{\"1\":{\"69\":1}}],[\"模块来管理组件\",{\"1\":{\"61\":1}}],[\"模块之间的作用域通常是独立的\",{\"1\":{\"19\":1}}],[\"模块可以确保在正确的地方提供服务和其他共享资源\",{\"1\":{\"19\":1}}],[\"模块帮助将相关的功能和组件分组在一起\",{\"1\":{\"19\":1}}],[\"模块的作用\",{\"0\":{\"19\":1}}],[\"模块化\",{\"1\":{\"12\":1}}],[\"模板的基地址\",{\"1\":{\"63\":1}}],[\"模板语法\",{\"1\":{\"45\":3}}],[\"模板驱动表单和\",{\"0\":{\"73\":1}}],[\"模板驱动表单可能是更好的选择\",{\"1\":{\"38\":1}}],[\"模板驱动表单可能更容易理解和上手\",{\"1\":{\"38\":1}}],[\"模板驱动表单的配置主要在html模板中完成\",{\"1\":{\"38\":1}}],[\"模板驱动表单是基于html模板的表单处理方式\",{\"1\":{\"36\":1}}],[\"模板驱动表单\",{\"0\":{\"36\":1},\"1\":{\"35\":1,\"73\":1}}],[\"模板\",{\"1\":{\"15\":1,\"16\":1}}],[\"模型也会相应地进行更新\",{\"1\":{\"14\":1}}],[\"视图会自动更新\",{\"1\":{\"14\":1}}],[\"当解析并执行完成js后\",{\"1\":{\"76\":1}}],[\"当遇到一个js时\",{\"1\":{\"76\":1}}],[\"当类被初始化之后\",{\"1\":{\"65\":1}}],[\"当没有配置base标签时\",{\"1\":{\"63\":1}}],[\"当observable或promise返回data时\",{\"1\":{\"55\":1}}],[\"当我们想路由到一个组件的时候使用router\",{\"1\":{\"48\":1}}],[\"当我们在html中使用<app\",{\"1\":{\"29\":1}}],[\"当\",{\"1\":{\"42\":1}}],[\"当把内容投影进组件之后调用\",{\"1\":{\"42\":1}}],[\"当组件数据绑定的输入属性发生变化是触发\",{\"1\":{\"42\":1}}],[\"当组件输入属性发生变化时调用\",{\"1\":{\"39\":1}}],[\"当angular创建appcomponent时\",{\"1\":{\"27\":1}}],[\"当angular创建一个组件或服务时\",{\"1\":{\"26\":1}}],[\"当angular启动时\",{\"1\":{\"17\":1}}],[\"当用户通过视图输入信息时\",{\"1\":{\"14\":1}}],[\"当模型发生变化时\",{\"1\":{\"14\":1}}],[\"当前组件使用setup形式\",{\"1\":{\"4\":1,\"88\":1}}],[\"en\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"err\",{\"1\":{\"64\":2}}],[\"error\",{\"1\":{\"64\":4}}],[\"errors\",{\"1\":{\"36\":1,\"37\":1}}],[\"emulated\",{\"1\":{\"49\":1}}],[\"emit\",{\"1\":{\"44\":1}}],[\"expression\",{\"1\":{\"31\":1}}],[\"exports\",{\"1\":{\"20\":1,\"34\":1}}],[\"export\",{\"1\":{\"16\":1,\"17\":1,\"20\":1,\"21\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"34\":1,\"37\":1,\"83\":2}}],[\"el\",{\"1\":{\"30\":1}}],[\"elementref\",{\"1\":{\"30\":2,\"62\":2}}],[\"else\",{\"1\":{\"7\":1,\"31\":1}}],[\"eventemitter\",{\"1\":{\"44\":1}}],[\"event\",{\"1\":{\"14\":1}}],[\"它还包含有浏览器的属性\",{\"1\":{\"72\":1}}],[\"它还可以相应地更改日期格式\",{\"1\":{\"59\":1}}],[\"它用于具有复杂数据流的单页应用程序\",{\"1\":{\"58\":1}}],[\"它有关于当前用户的一些信息或属性\",{\"1\":{\"56\":1}}],[\"它有一个名为name的属性\",{\"1\":{\"29\":1}}],[\"它接收一个simplechanges对象作为参数\",{\"1\":{\"39\":1}}],[\"它完全在组件类中创建和管理表单模型\",{\"1\":{\"37\":1}}],[\"它依赖于ngmodel指令来建立数据绑定\",{\"1\":{\"36\":1}}],[\"它依赖于一个名为dataservice的服务\",{\"1\":{\"27\":1}}],[\"它导入并配置了routermodule\",{\"1\":{\"34\":1}}],[\"它描述了应用程序中的每个可访问路径以及与之关联的组件\",{\"1\":{\"33\":1}}],[\"它类似于\",{\"1\":{\"31\":1}}],[\"它可以动态地为元素添加或移除css类\",{\"1\":{\"30\":1}}],[\"它可以包含文本\",{\"1\":{\"16\":1}}],[\"它们在特定的时刻被angular框架调用\",{\"1\":{\"39\":1}}],[\"它们通常以\",{\"1\":{\"30\":1,\"31\":1}}],[\"它们实际上操作的是同一份数据\",{\"1\":{\"24\":1}}],[\"它包含了html模板\",{\"1\":{\"29\":1}}],[\"它允许在不直接创建对象的情况下获取它们的实例\",{\"1\":{\"25\":1}}],[\"它是一个帮助我们维护应用程序状态的库\",{\"1\":{\"58\":1}}],[\"它是一个独立的\",{\"1\":{\"15\":1}}],[\"它是一种在组件之间共享代码\",{\"1\":{\"22\":1}}],[\"它提供了一种结构化的方式来管理组件\",{\"1\":{\"18\":1}}],[\"它会在元素上设置背景颜色为黄色\",{\"1\":{\"30\":1}}],[\"它会发现dataservice参数\",{\"1\":{\"27\":1}}],[\"它会查看其构造函数参数列表\",{\"1\":{\"26\":1}}],[\"它会找到这个标签并替换为应用程序的顶级组件\",{\"1\":{\"17\":1}}],[\"它会通过事件\",{\"1\":{\"14\":1}}],[\"它最初在2010年作为angularjs发布\",{\"1\":{\"11\":1}}],[\"在vue3中\",{\"1\":{\"83\":1}}],[\"在执行解析完成的js\",{\"1\":{\"78\":1}}],[\"在一起执行\",{\"1\":{\"77\":1}}],[\"在解析html时\",{\"1\":{\"77\":1}}],[\"在父组件的\",{\"1\":{\"74\":2}}],[\"在初始化的时候所有路由都会加载\",{\"1\":{\"66\":1}}],[\"在constructor中是取不到输入属性的值的\",{\"1\":{\"65\":1}}],[\"在es6中\",{\"1\":{\"65\":1}}],[\"在exports数组中\",{\"1\":{\"20\":1}}],[\"在浏览器中开始jit的编译过程\",{\"1\":{\"57\":1}}],[\"在浏览器中进行\",{\"1\":{\"57\":1}}],[\"在服务器端验证凭据并返回json\",{\"1\":{\"56\":1}}],[\"在传统的web技术中\",{\"1\":{\"53\":1}}],[\"在标记之间可以添加内容\",{\"1\":{\"47\":1}}],[\"在angular\",{\"1\":{\"65\":1}}],[\"在angular中有三种方法可以做到这一点\",{\"1\":{\"49\":1}}],[\"在angular每次销毁组件或指令之前调用\",{\"1\":{\"42\":1}}],[\"在angular第一次显示展示组件的绑定属性后调用\",{\"1\":{\"42\":1}}],[\"在appcomponent的构造函数中\",{\"1\":{\"27\":1}}],[\"在每次变更检测周期中都会被调用\",{\"1\":{\"40\":1}}],[\"在每个变更检测周期中\",{\"1\":{\"39\":2}}],[\"在组件的constructor中引入\",{\"1\":{\"62\":1}}],[\"在组件的内容投影\",{\"1\":{\"39\":1}}],[\"在组件即将被销毁前调用\",{\"1\":{\"39\":1}}],[\"在组件及其所有子视图完成初始化后调用\",{\"1\":{\"39\":1}}],[\"在组件或另一个服务中\",{\"1\":{\"26\":1}}],[\"在第一次ngdocheck之后调用\",{\"1\":{\"39\":1}}],[\"在模板中使用formcontrolname指令将控件与表单模型关联起来\",{\"1\":{\"37\":1}}],[\"在构造函数中使用formbuilder来创建表单控件及其验证规则\",{\"1\":{\"37\":1}}],[\"在imports数组中添加我们的模块\",{\"1\":{\"21\":1}}],[\"在index\",{\"0\":{\"8\":1},\"1\":{\"17\":1}}],[\"在这里\",{\"1\":{\"34\":1}}],[\"在这个例子中\",{\"1\":{\"16\":1,\"20\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"34\":1,\"36\":1,\"37\":1}}],[\"在这种模式下\",{\"1\":{\"14\":1}}],[\"在更复杂的场景下\",{\"1\":{\"14\":1}}],[\"便于获取帮助和集成其他技术栈\",{\"1\":{\"13\":1}}],[\"拥有庞大的开发者社区和丰富的第三方库\",{\"1\":{\"13\":1}}],[\"社区活跃\",{\"1\":{\"13\":1}}],[\"内置了对单元测试和端到端测试的支持\",{\"1\":{\"13\":1}}],[\"内置的路由器支持多视图和深层链接\",{\"1\":{\"12\":1}}],[\"测试方便\",{\"1\":{\"24\":1}}],[\"测试友好\",{\"1\":{\"13\":1}}],[\"测试和部署\",{\"1\":{\"13\":1}}],[\"方式\",{\"1\":{\"74\":1}}],[\"方便的跟踪表单控件值的变化\",{\"1\":{\"73\":1}}],[\"方便项目的初始化\",{\"1\":{\"13\":1}}],[\"方法\",{\"1\":{\"34\":1}}],[\"方法不同\",{\"0\":{\"81\":1},\"1\":{\"3\":1,\"85\":1}}],[\"工具链支持\",{\"1\":{\"13\":1}}],[\"基于组件创建应用\",{\"1\":{\"46\":1}}],[\"基于typescript构建\",{\"1\":{\"13\":1}}],[\"基本类型\",{\"0\":{\"90\":1},\"1\":{\"4\":1}}],[\"以防内存泄露\",{\"1\":{\"42\":1}}],[\"以便在组件的不同阶段进行操作\",{\"1\":{\"39\":1}}],[\"以便其他模块可以使用它\",{\"1\":{\"34\":1}}],[\"以提高应用的启动速度和性能\",{\"1\":{\"33\":1}}],[\"以下是angular中一些常用的生命周期钩子函数及其作用\",{\"1\":{\"39\":1}}],[\"以下是angular框架的一些特点和优势\",{\"1\":{\"11\":1}}],[\"以下是一个简化的组件生命周期钩子函数执行顺序\",{\"1\":{\"40\":1}}],[\"以下是一个简单的例子\",{\"1\":{\"27\":1,\"34\":1}}],[\"以下是一个简单的模块定义示例\",{\"1\":{\"20\":1}}],[\"以下是一个自定义结构指令的例子\",{\"1\":{\"31\":1}}],[\"以下是一个自定义属性指令的例子\",{\"1\":{\"30\":1}}],[\"以及启动的component\",{\"1\":{\"61\":1}}],[\"以及如何配置和使用路由来实现单页面应用\",{\"0\":{\"32\":1}}],[\"以及如何在组件或服务中使用依赖注入\",{\"0\":{\"25\":1}}],[\"以及为什么使用服务来共享数据和逻辑\",{\"0\":{\"22\":1}}],[\"以及它与双向数据绑定的区别\",{\"0\":{\"14\":1}}],[\"以及通过angular\",{\"1\":{\"13\":1}}],[\"utf\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"uglify和tree\",{\"1\":{\"67\":1}}],[\"used<\",{\"1\":{\"47\":1}}],[\"unsubscribe\",{\"1\":{\"64\":1}}],[\"unlessdirective\",{\"1\":{\"31\":1}}],[\"universal实现服务器端渲染\",{\"1\":{\"13\":1}}],[\"ui\",{\"1\":{\"15\":1}}],[\"url\",{\"1\":{\"7\":7,\"8\":1}}],[\"还可以借助angular\",{\"1\":{\"13\":1}}],[\"还不需要循环\",{\"1\":{\"3\":1,\"84\":1,\"85\":1}}],[\"提早检测模板错误\",{\"1\":{\"57\":1}}],[\"提高了代码的效率和可读性\",{\"1\":{\"24\":1}}],[\"提高代码质量和可维护性\",{\"1\":{\"13\":1}}],[\"提供者注册\",{\"1\":{\"26\":1}}],[\"提供的信息\",{\"1\":{\"16\":1}}],[\"提供静态类型检查\",{\"1\":{\"13\":1}}],[\"提供了丰富的导航功能\",{\"1\":{\"12\":1}}],[\"提升项目的维护性\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"双向数据绑定的原理\",{\"0\":{\"45\":1}}],[\"双向数据绑定是一种允许数据在模型\",{\"1\":{\"14\":1}}],[\"双向数据绑定\",{\"1\":{\"12\":1,\"52\":1}}],[\"双向绑定到组件中的属性\",{\"1\":{\"36\":1}}],[\"双向绑定\",{\"0\":{\"81\":1},\"1\":{\"3\":1,\"85\":1}}],[\"指令分类\",{\"0\":{\"43\":1}}],[\"指令将表单与一个局部变量关联起来\",{\"1\":{\"36\":1}}],[\"指令和管道可以在外部模块中使用\",{\"1\":{\"20\":1}}],[\"指令和管道\",{\"1\":{\"20\":3,\"21\":1}}],[\"指令和其他angular特性\",{\"1\":{\"16\":1}}],[\"指令系统\",{\"1\":{\"12\":1}}],[\"指令\",{\"1\":{\"12\":1,\"18\":1,\"69\":1}}],[\"这个方法可以用来清理资源\",{\"1\":{\"39\":1}}],[\"这个方法可以用来处理与内容变化有关的任务\",{\"1\":{\"39\":1}}],[\"这个方法可以用来处理与视图变化有关的任务\",{\"1\":{\"39\":1}}],[\"这个方法可以用来访问dom元素并执行与视图相关的操作\",{\"1\":{\"39\":1}}],[\"这个方法可以用来检测和响应输入属性的变化\",{\"1\":{\"39\":1}}],[\"这个方法通常用于任何复杂的初始化逻辑\",{\"1\":{\"39\":1}}],[\"这种情况下就可以使用<ng\",{\"1\":{\"47\":1}}],[\"这种形式的表单适用于较小且简单的需求\",{\"1\":{\"36\":1}}],[\"这种机制使得代码更容易复用和测试\",{\"1\":{\"27\":1}}],[\"这种机制使得开发者无需手动处理数据同步问题\",{\"1\":{\"14\":1}}],[\"这两种方式在实现细节和使用方法上有所不同\",{\"1\":{\"35\":1}}],[\"这可以通过routerlink指令或编程方式实现\",{\"1\":{\"33\":1}}],[\"这可以通过\",{\"1\":{\"26\":1}}],[\"这意味着在这个阶段\",{\"1\":{\"39\":1}}],[\"这意味着当多个组件同时访问同一个服务时\",{\"1\":{\"24\":1}}],[\"这意味着它们可以在需要的地方被注入到组件或其它服务中\",{\"1\":{\"23\":1}}],[\"这意味着一个模块中定义的服务不会自动在其他模块中可用\",{\"1\":{\"19\":1}}],[\"这里有一个名为name的属性\",{\"1\":{\"16\":1}}],[\"这里是一个带有插值绑定的标题标签\",{\"1\":{\"16\":1}}],[\"这里是<app\",{\"1\":{\"16\":1}}],[\"这里可以修改为自己所需要的外部链接\",{\"1\":{\"7\":1}}],[\"这包括与用户交互\",{\"1\":{\"16\":1}}],[\"这些方法提供了执行代码的机会\",{\"1\":{\"39\":1}}],[\"这些部分共同定义了组件的外观和行为\",{\"1\":{\"15\":1}}],[\"这些特点和优势使angular成为构建企业级web应用的理想选择\",{\"1\":{\"13\":1}}],[\"这样可以确保数据仍然遵循单向流动的原则\",{\"1\":{\"14\":1}}],[\"这是因为html解析是遇到js后\",{\"1\":{\"77\":1}}],[\"这是因为他在解析html时\",{\"1\":{\"76\":1}}],[\"这是因为单向数据流使得数据流动的方向更为明确\",{\"1\":{\"14\":1}}],[\"这是通过装饰器\",{\"1\":{\"16\":1}}],[\"这是一个typescript类\",{\"1\":{\"16\":1}}],[\"这是一个html文件\",{\"1\":{\"16\":1}}],[\"这是一种自包含的视图和逻辑单元\",{\"1\":{\"12\":1}}],[\"使app实现模块化\",{\"1\":{\"61\":1}}],[\"使得代码更加模块化\",{\"1\":{\"25\":1}}],[\"使得代码更易于测试和复用\",{\"1\":{\"12\":1}}],[\"使得组件专注于视图展示\",{\"1\":{\"24\":1}}],[\"使得整个应用更加模块化和可管理\",{\"1\":{\"19\":1}}],[\"使代码更易于维护和复用\",{\"1\":{\"18\":1}}],[\"使其易于理解和维护\",{\"1\":{\"11\":1}}],[\"使用方便\",{\"1\":{\"73\":1}}],[\"使用mvc模式\",{\"1\":{\"68\":1}}],[\"使用angular的好处\",{\"0\":{\"68\":1}}],[\"使用loadchildren配置路由\",{\"1\":{\"66\":1}}],[\"使用在class中\",{\"1\":{\"65\":1}}],[\"使用teleport传送门代码示例及效果演示\",{\"0\":{\"96\":1}}],[\"使用tsc编译\",{\"1\":{\"57\":1}}],[\"使用typescript开发\",{\"1\":{\"57\":1}}],[\"使用\",{\"1\":{\"36\":2,\"44\":1,\"64\":1}}],[\"使用服务来共享数据和逻辑有以下几个原因\",{\"1\":{\"24\":1}}],[\"使用模块\",{\"0\":{\"21\":1}}],[\"使用hooks去管理维护代码\",{\"1\":{\"5\":1,\"86\":1}}],[\"使用场景\",{\"1\":{\"4\":2,\"65\":1,\"88\":2}}],[\"也就是说\",{\"1\":{\"65\":1}}],[\"也被称为angular\",{\"1\":{\"11\":1}}],[\"也可以组合式api或setup语法糖形式\",{\"1\":{\"3\":1,\"85\":1}}],[\"动态和响应式的单页面web应用程序\",{\"1\":{\"11\":1}}],[\"请举例说明模板驱动表单和响应式表单的区别和用法\",{\"0\":{\"35\":1}}],[\"请举例说明它们的用法\",{\"0\":{\"28\":1}}],[\"请解释一下angular中的依赖注入\",{\"0\":{\"25\":1}}],[\"请解释一下组件的结构和用法\",{\"0\":{\"15\":1}}],[\"请说明一下模块的作用和如何定义和使用模块\",{\"0\":{\"18\":1}}],[\"请简要介绍一下angular框架的特点和优势\",{\"0\":{\"11\":1}}],[\"请介绍一下teleport组件及其使用场景\",{\"1\":{\"4\":1}}],[\"请介绍一下vue3常用的响应式数据类型\",{\"1\":{\"4\":1}}],[\"问题就在于请求\",{\"1\":{\"53\":1}}],[\"问\",{\"0\":{\"11\":1,\"14\":1,\"15\":1,\"18\":1,\"22\":1,\"25\":1,\"28\":1,\"32\":1,\"35\":1,\"39\":1}}],[\"absolute\",{\"1\":{\"95\":1,\"96\":1}}],[\"about\",{\"1\":{\"34\":5}}],[\"aboutcomponent\",{\"1\":{\"34\":2}}],[\"age\",{\"1\":{\"91\":1,\"92\":1,\"93\":2}}],[\"addbtn\",{\"1\":{\"82\":2,\"83\":4}}],[\"alt=\",{\"1\":{\"82\":1,\"83\":2}}],[\"aot优势\",{\"1\":{\"57\":1}}],[\"aot\",{\"1\":{\"57\":1}}],[\"aot编译\",{\"0\":{\"57\":1}}],[\"ahead\",{\"1\":{\"57\":1}}],[\"authorization\",{\"1\":{\"56\":1}}],[\"authorization的区别\",{\"0\":{\"56\":1}}],[\"authentication\",{\"0\":{\"56\":1},\"1\":{\"56\":1}}],[\"any\",{\"1\":{\"74\":1}}],[\"and\",{\"0\":{\"56\":1}}],[\"angular路由器使用base\",{\"1\":{\"63\":1}}],[\"angular启动\",{\"1\":{\"57\":1}}],[\"angular面试\",{\"1\":{\"42\":1}}],[\"angular面试题及答案\",{\"1\":{\"42\":1}}],[\"angular面试题汇总\",{\"0\":{\"41\":1}}],[\"angular提供了两种主要的方式来处理表单\",{\"1\":{\"35\":1}}],[\"angular提供了一种结构化的方式来组织代码\",{\"1\":{\"11\":1}}],[\"angular还支持懒加载\",{\"1\":{\"33\":1}}],[\"angular内置的\",{\"1\":{\"31\":1}}],[\"angular内置的ngclass就是一个属性指令\",{\"1\":{\"30\":1}}],[\"angular会渲染出这个组件的视图\",{\"1\":{\"29\":1}}],[\"angular会调用它的工厂方法创建一个新的dataservice实例\",{\"1\":{\"27\":1}}],[\"angular就会将这个依赖项的实例注入到构造函数中\",{\"1\":{\"26\":1}}],[\"angular服务提供了一种强大的方法来管理应用程序的业务逻辑和数据\",{\"1\":{\"24\":1}}],[\"angular组件是angular应用的主要构建块\",{\"1\":{\"15\":1}}],[\"angular通常推荐使用单向数据流来保证代码的可预测性和易于调试性\",{\"1\":{\"14\":1}}],[\"angular通过其强大的数据绑定机制实现了模型与视图之间的自动同步\",{\"1\":{\"12\":1}}],[\"angular中的生命周期钩子函数是一组预定义的方法\",{\"1\":{\"39\":1}}],[\"angular中的表单处理有哪些不同的方式\",{\"0\":{\"35\":1}}],[\"angular中的路由\",{\"1\":{\"32\":1}}],[\"angular中的指令主要有三种类型\",{\"1\":{\"28\":1}}],[\"angular中的指令\",{\"0\":{\"28\":1}}],[\"angular中的依赖注入\",{\"1\":{\"25\":1}}],[\"angular中的服务\",{\"1\":{\"22\":1}}],[\"angular中的模块\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"angular中的单向数据流是指数据从父组件流向子组件的传递方式\",{\"1\":{\"14\":1}}],[\"angular中传统的双向数据绑定主要通过ngmodel指令实现\",{\"1\":{\"14\":1}}],[\"angular的核心部件有哪些\",{\"0\":{\"69\":1}}],[\"angular的核心概念是组件\",{\"1\":{\"12\":1}}],[\"angular的懒加载\",{\"0\":{\"66\":1}}],[\"angular的双向数据绑定就是\",{\"1\":{\"45\":1}}],[\"angular的服务是通过依赖注入\",{\"1\":{\"23\":1}}],[\"angular的设计鼓励测试驱动开发\",{\"1\":{\"13\":1}}],[\"angular\",{\"0\":{\"101\":1},\"1\":{\"13\":1,\"16\":1,\"17\":2,\"20\":2,\"21\":2,\"27\":2,\"29\":1,\"30\":1,\"31\":1,\"34\":2,\"37\":2,\"42\":2}}],[\"angular不仅适用于浏览器环境\",{\"1\":{\"13\":1}}],[\"angular利用rxjs库支持响应式编程范式\",{\"1\":{\"12\":1}}],[\"angular允许开发者创建自定义指令来扩展html元素的功能\",{\"1\":{\"12\":1}}],[\"angular采用依赖注入模式来管理服务和组件间的依赖关系\",{\"1\":{\"12\":1}}],[\"angular使用模块来组织应用的不同部分\",{\"1\":{\"12\":1}}],[\"angular是一个由google维护的开源前端框架\",{\"1\":{\"11\":1}}],[\"angular是什么\",{\"0\":{\"11\":1}}],[\"angular最新面试题\",{\"0\":{\"10\":1}}],[\"assets\",{\"1\":{\"82\":1,\"83\":2}}],[\"async是html与js共同解析并执行的\",{\"1\":{\"79\":1}}],[\"async是和html解析同步的\",{\"1\":{\"75\":1}}],[\"async延迟方式\",{\"0\":{\"77\":1}}],[\"async\",{\"1\":{\"75\":3,\"77\":1,\"79\":2}}],[\"asyncpipe\",{\"0\":{\"55\":1}}],[\"asp\",{\"1\":{\"53\":1}}],[\"a\",{\"1\":{\"47\":1,\"64\":3,\"82\":2,\"83\":4,\"84\":2,\"95\":2}}],[\"a>\",{\"1\":{\"34\":2}}],[\"attribute\",{\"0\":{\"30\":1},\"1\":{\"28\":1,\"30\":1}}],[\"approutingmodule\",{\"1\":{\"34\":1}}],[\"appunless=\",{\"1\":{\"31\":1}}],[\"appunless\",{\"1\":{\"31\":2}}],[\"apphighlight\",{\"1\":{\"30\":1}}],[\"appcomponent\",{\"1\":{\"21\":3,\"27\":1}}],[\"appcontext\",{\"1\":{\"4\":1,\"87\":1}}],[\"app<\",{\"1\":{\"17\":1}}],[\"appmodule就可以访问mymodule中导出的所有组件\",{\"1\":{\"21\":1}}],[\"appmodule\",{\"1\":{\"17\":1,\"21\":1}}],[\"app\",{\"1\":{\"4\":4,\"16\":1,\"17\":2,\"21\":1,\"27\":2,\"29\":2,\"37\":1,\"47\":1,\"87\":3,\"88\":1}}],[\"三\",{\"0\":{\"9\":1,\"78\":1,\"92\":1}}],[\">按钮<\",{\"1\":{\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\">添加<\",{\"1\":{\"82\":1,\"83\":2}}],[\">111111<\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\">submit<\",{\"1\":{\"36\":1,\"37\":1}}],[\">name\",{\"1\":{\"36\":2,\"37\":2}}],[\">about<\",{\"1\":{\"34\":1}}],[\">home<\",{\"1\":{\"34\":1}}],[\"><\",{\"1\":{\"8\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"95\":1,\"96\":1}}],[\">\",{\"1\":{\"8\":1,\"17\":1,\"36\":3,\"37\":4,\"76\":3,\"77\":3,\"78\":3,\"82\":3,\"83\":6,\"84\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":5,\"96\":2}}],[\"标签的作用\",{\"0\":{\"63\":1}}],[\"标签\",{\"0\":{\"8\":1}}],[\"二\",{\"0\":{\"8\":1,\"14\":1,\"77\":1,\"84\":1,\"91\":1,\"96\":1}}],[\"`<h1>hello\",{\"1\":{\"16\":1,\"29\":1}}],[\"`\",{\"1\":{\"7\":1,\"27\":2,\"37\":2}}],[\"`$\",{\"1\":{\"7\":1}}],[\"orange\",{\"1\":{\"95\":1,\"96\":1}}],[\"orderby\",{\"1\":{\"70\":1}}],[\"of\",{\"1\":{\"57\":1}}],[\"obj\",{\"1\":{\"82\":6,\"83\":15,\"91\":3,\"92\":3,\"93\":2}}],[\"object的子成员\",{\"1\":{\"72\":1}}],[\"object\",{\"0\":{\"84\":1},\"1\":{\"3\":1,\"72\":2,\"84\":2,\"85\":1}}],[\"observer\",{\"0\":{\"64\":1},\"1\":{\"64\":6}}],[\"observable\",{\"0\":{\"64\":1},\"1\":{\"64\":2}}],[\"observable可取消\",{\"1\":{\"54\":1}}],[\"observable是一个stream\",{\"1\":{\"54\":1}}],[\"observables\",{\"0\":{\"54\":1},\"1\":{\"54\":1}}],[\"other\",{\"1\":{\"36\":1,\"37\":1}}],[\"outlet占位符是路由器用来渲染当前激活组件的地方\",{\"1\":{\"34\":1}}],[\"outlet>\",{\"1\":{\"34\":1,\"50\":1}}],[\"outlet><\",{\"1\":{\"34\":1,\"50\":1}}],[\"output\",{\"1\":{\"14\":1,\"44\":2}}],[\"onsubmit\",{\"1\":{\"36\":1,\"37\":2}}],[\"onshow\",{\"1\":{\"7\":1}}],[\"onload\",{\"1\":{\"7\":1}}],[\"options\",{\"1\":{\"7\":3}}],[\"href\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"href=\",{\"1\":{\"17\":1}}],[\"highlightdirective\",{\"1\":{\"30\":1}}],[\"homeview\",{\"1\":{\"83\":2}}],[\"home\",{\"1\":{\"34\":2,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":2}}],[\"homecomponent\",{\"1\":{\"34\":2}}],[\"hostbinding\",{\"1\":{\"30\":2}}],[\"hooks\",{\"1\":{\"4\":2,\"5\":1,\"86\":1}}],[\"height\",{\"1\":{\"95\":2,\"96\":1}}],[\"heroformcomponent\",{\"1\":{\"37\":1}}],[\"heroform\",{\"1\":{\"36\":1,\"37\":9}}],[\"heroform=\",{\"1\":{\"36\":2}}],[\"hero\",{\"1\":{\"36\":1,\"37\":1}}],[\"head>\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"helloworldcomponent\",{\"1\":{\"16\":1,\"17\":3,\"29\":1}}],[\"hello\",{\"1\":{\"16\":2,\"17\":2,\"29\":3}}],[\"html所在目录中启动服务器\",{\"1\":{\"63\":1}}],[\"html\",{\"1\":{\"53\":2,\"61\":2,\"63\":1}}],[\"html>\",{\"1\":{\"17\":2,\"76\":2,\"77\":2,\"78\":2}}],[\"html或其他适当的位置添加<app\",{\"1\":{\"17\":1}}],[\"https\",{\"1\":{\"7\":1}}],[\"h1>\",{\"1\":{\"27\":1,\"51\":1}}],[\"h1>`\",{\"1\":{\"16\":1,\"29\":1}}],[\"h1\",{\"1\":{\"16\":1}}],[\"position\",{\"1\":{\"95\":2,\"96\":2}}],[\"png\",{\"1\":{\"82\":1,\"83\":2}}],[\"paragraph<\",{\"1\":{\"47\":1}}],[\"path\",{\"1\":{\"34\":2,\"66\":3}}],[\"page\",{\"1\":{\"7\":1}}],[\"private\",{\"1\":{\"27\":1,\"30\":1,\"31\":2,\"37\":1}}],[\"propkey\",{\"1\":{\"84\":4}}],[\"props\",{\"1\":{\"14\":1}}],[\"promise或observable可以直接在模板中使用\",{\"1\":{\"55\":1}}],[\"promise不可取消\",{\"1\":{\"54\":1}}],[\"promise只处理一个事件\",{\"1\":{\"54\":1}}],[\"promise是eager的\",{\"1\":{\"54\":1}}],[\"projection\",{\"1\":{\"39\":1,\"74\":1}}],[\"process\",{\"1\":{\"37\":1}}],[\"providers\",{\"1\":{\"21\":1}}],[\"provide\",{\"1\":{\"4\":1,\"88\":1}}],[\"proxy代理\",{\"1\":{\"4\":1,\"88\":1}}],[\"proxy不需要\",{\"1\":{\"3\":1,\"85\":1}}],[\"proxy\",{\"0\":{\"84\":1},\"1\":{\"3\":1,\"84\":2,\"85\":1}}],[\"p>那我们如果想在angular的标签之间添加内容呢\",{\"1\":{\"47\":1}}],[\"p>\",{\"1\":{\"27\":1}}],[\"platform\",{\"1\":{\"17\":1,\"21\":1}}],[\"一样可以获取到box\",{\"1\":{\"78\":1}}],[\"一起的\",{\"1\":{\"75\":1}}],[\"一般在constructor中进行一些简单的初始化操作\",{\"1\":{\"65\":1}}],[\"一旦jwt返回给给客户端\",{\"1\":{\"56\":1}}],[\"一个是空路径\",{\"1\":{\"34\":1}}],[\"一个简单的angular组件示例可能如下所示\",{\"1\":{\"16\":1}}],[\"一个用户拥有某些权限\",{\"1\":{\"4\":1,\"88\":1}}],[\"一\",{\"0\":{\"7\":1,\"11\":1,\"76\":1,\"81\":1,\"90\":1,\"95\":1}}],[\"width\",{\"1\":{\"76\":1,\"77\":1,\"78\":1,\"95\":2,\"96\":1}}],[\"width=device\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"world>标签时\",{\"1\":{\"29\":1}}],[\"world><\",{\"1\":{\"29\":1}}],[\"world>\",{\"1\":{\"16\":1}}],[\"world\",{\"1\":{\"16\":2,\"17\":2,\"29\":2}}],[\"wxml中使用\",{\"0\":{\"8\":1}}],[\"webviewurl\",{\"1\":{\"7\":2}}],[\"web\",{\"0\":{\"6\":1},\"1\":{\"8\":1,\"56\":1}}],[\"watch\",{\"1\":{\"4\":1,\"88\":1}}],[\"需要下载的angular框架体积更小\",{\"1\":{\"57\":1}}],[\"需要的异步请求更少\",{\"1\":{\"57\":1}}],[\"需要在另一个模块中导入它\",{\"1\":{\"21\":1}}],[\"需要在页面居中位置展示\",{\"1\":{\"4\":1,\"97\":1}}],[\"需要使用\",{\"1\":{\"20\":1}}],[\"需要用defineprops接收\",{\"1\":{\"4\":1,\"88\":1}}],[\"target\",{\"1\":{\"84\":4}}],[\"type\",{\"1\":{\"74\":1}}],[\"typescript编译车javascript\",{\"1\":{\"57\":1}}],[\"typescript开发angular应用\",{\"1\":{\"57\":1}}],[\"type=\",{\"1\":{\"36\":2,\"37\":2,\"75\":2,\"84\":2}}],[\"time\",{\"1\":{\"57\":2}}],[\"title\",{\"1\":{\"27\":2}}],[\"title>\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"the\",{\"1\":{\"37\":1}}],[\"this\",{\"1\":{\"7\":4,\"27\":1,\"30\":1,\"31\":3,\"37\":3,\"83\":6}}],[\"teleport>\",{\"1\":{\"96\":1}}],[\"teleport组件及其使用场景\",{\"0\":{\"94\":1}}],[\"teleport组件是一个传送门\",{\"1\":{\"4\":1,\"97\":1}}],[\"test>\",{\"1\":{\"47\":1}}],[\"test><\",{\"1\":{\"47\":1}}],[\"text=\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"text\",{\"1\":{\"36\":1,\"37\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"84\":2}}],[\"template>\",{\"1\":{\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":3,\"96\":1}}],[\"templates\",{\"1\":{\"69\":1}}],[\"templateref<any>\",{\"1\":{\"31\":1}}],[\"templateref\",{\"1\":{\"31\":3}}],[\"template定义了组件的html内容\",{\"1\":{\"16\":1}}],[\"template\",{\"1\":{\"15\":1,\"16\":1,\"27\":1,\"29\":1,\"35\":1,\"37\":1,\"73\":1}}],[\"to=\",{\"1\":{\"96\":1}}],[\"top\",{\"1\":{\"95\":2,\"96\":2}}],[\"token\",{\"1\":{\"56\":1}}],[\"touched\",{\"1\":{\"36\":1,\"37\":1}}],[\"toolkit开发原生移动应用\",{\"1\":{\"13\":1}}],[\"torefs\",{\"0\":{\"93\":1},\"1\":{\"4\":1,\"93\":2}}],[\"toref\",{\"0\":{\"92\":1},\"1\":{\"4\":1,\"92\":2,\"93\":1}}],[\"解耦组件\",{\"1\":{\"24\":1}}],[\"解释一下angular中的生命周期钩子函数是什么\",{\"0\":{\"39\":1}}],[\"解释一下angular中的路由\",{\"0\":{\"32\":1}}],[\"解释一下angular中的服务\",{\"0\":{\"22\":1}}],[\"解释一下angular中的单向数据流是什么\",{\"0\":{\"14\":1}}],[\"解构多个值\",{\"0\":{\"93\":1},\"1\":{\"4\":1,\"93\":1}}],[\"解构某一个值\",{\"0\":{\"92\":1},\"1\":{\"4\":1,\"92\":1}}],[\"解决\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"解决问题\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"那么会导致\",{\"1\":{\"83\":1}}],[\"那么\",{\"1\":{\"79\":1}}],[\"那么他们两个会并行解析\",{\"1\":{\"77\":1}}],[\"那么右侧就是slot\",{\"1\":{\"4\":1,\"88\":1}}],[\"那么vue是数据驱动dom\",{\"1\":{\"4\":1,\"88\":1}}],[\"具名\",{\"1\":{\"4\":1,\"88\":1}}],[\"匿名\",{\"1\":{\"4\":1,\"88\":1}}],[\"说白了就是静态的数据\",{\"1\":{\"4\":1,\"88\":1}}],[\"说明\",{\"1\":{\"4\":13,\"5\":1,\"86\":1,\"88\":12}}],[\"margin\",{\"1\":{\"95\":2,\"96\":2}}],[\"markraw\",{\"1\":{\"4\":1,\"88\":1}}],[\"methods\",{\"1\":{\"83\":2}}],[\"metadata\",{\"1\":{\"15\":1,\"69\":1}}],[\"myelement\",{\"1\":{\"62\":1}}],[\"my\",{\"1\":{\"21\":1,\"27\":1}}],[\"mymodule\",{\"1\":{\"20\":1,\"21\":2}}],[\"mypipe\",{\"1\":{\"20\":2}}],[\"mydirective\",{\"1\":{\"20\":1}}],[\"mycomponent\",{\"1\":{\"20\":2}}],[\"mo\",{\"1\":{\"95\":2,\"96\":2}}],[\"modules\",{\"1\":{\"69\":1}}],[\"module声明了哪些模块可以被其他模块使用\",{\"1\":{\"61\":1}}],[\"module不会控制视图\",{\"1\":{\"61\":1}}],[\"module是包括一个或多个组件\",{\"1\":{\"61\":1}}],[\"module\",{\"0\":{\"18\":1},\"1\":{\"18\":1,\"21\":1,\"66\":2}}],[\"model\",{\"1\":{\"14\":1,\"72\":2}}],[\"mobile\",{\"1\":{\"13\":1}}],[\"mixin\",{\"1\":{\"4\":1,\"88\":1}}],[\"监听\",{\"1\":{\"4\":1,\"88\":1}}],[\"9\",{\"0\":{\"50\":1},\"1\":{\"4\":1,\"69\":1,\"88\":1}}],[\"8\",{\"0\":{\"49\":1},\"1\":{\"4\":1,\"69\":1,\"76\":1,\"77\":1,\"78\":1,\"88\":1}}],[\"计算属性\",{\"1\":{\"4\":1,\"88\":1}}],[\"回调函数是放在promise中的\",{\"1\":{\"4\":1,\"88\":1}}],[\"等绿色html执行完成后\",{\"1\":{\"78\":1}}],[\"等html与js解析好后\",{\"1\":{\"77\":1}}],[\"等html全部解析完成\",{\"1\":{\"75\":1}}],[\"等真正访问到子模块之后\",{\"1\":{\"66\":1}}],[\"等待下一次\",{\"1\":{\"4\":1,\"88\":1}}],[\"等于vue2的==\",{\"1\":{\"4\":1,\"88\":1}}],[\"自定义事件需要使用defineemits\",{\"1\":{\"4\":1,\"88\":1}}],[\"自定义指令\",{\"1\":{\"4\":1,\"43\":1,\"88\":1}}],[\"自己封装插件的时候需要把方法添加到对象中\",{\"1\":{\"4\":1,\"88\":1}}],[\"局部\",{\"1\":{\"4\":1,\"88\":1}}],[\"全局混入\",{\"1\":{\"4\":1,\"88\":1}}],[\"不是顺次执行js脚本\",{\"1\":{\"75\":1}}],[\"不同点\",{\"1\":{\"74\":1}}],[\"不易于单元测试\",{\"1\":{\"73\":1}}],[\"不受当前组件的限制\",{\"1\":{\"4\":1,\"97\":1}}],[\"不被new\",{\"1\":{\"4\":1,\"88\":1}}],[\"不能删除\",{\"1\":{\"4\":1,\"88\":1}}],[\"不好维护和查询数据来源\",{\"1\":{\"4\":2,\"88\":2}}],[\"场景\",{\"1\":{\"4\":6,\"88\":6}}],[\"date\",{\"1\":{\"70\":1}}],[\"dataservice\",{\"1\":{\"27\":4}}],[\"data\",{\"1\":{\"7\":2,\"27\":4,\"37\":1,\"45\":2,\"69\":1,\"83\":2,\"84\":6}}],[\"driven\",{\"1\":{\"35\":1,\"73\":1}}],[\"display\",{\"1\":{\"95\":1}}],[\"disabled\",{\"1\":{\"36\":1,\"37\":1}}],[\"div>\",{\"1\":{\"36\":3,\"37\":3,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":4,\"96\":2}}],[\"dirty\",{\"0\":{\"71\":1},\"1\":{\"36\":1,\"37\":1,\"71\":1}}],[\"directives\",{\"1\":{\"69\":1}}],[\"directive是可重复使用的行为\",{\"1\":{\"46\":1}}],[\"directive修饰\",{\"1\":{\"46\":1}}],[\"directive使用注解\",{\"1\":{\"46\":1}}],[\"directive的形式出现在元素上\",{\"1\":{\"31\":1}}],[\"directive\",{\"0\":{\"28\":1,\"30\":1,\"31\":1},\"1\":{\"4\":1,\"28\":2,\"30\":2,\"31\":2,\"47\":1,\"88\":1}}],[\"di\",{\"1\":{\"23\":1,\"25\":1}}],[\"document\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"doctype\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"dom有w3c的标准\",{\"1\":{\"72\":1}}],[\"dom用来操作html文档\",{\"1\":{\"72\":1}}],[\"dom是一棵树结构\",{\"1\":{\"72\":1}}],[\"dom是document\",{\"1\":{\"72\":1}}],[\"dom代表的是网页的内容\",{\"1\":{\"72\":1}}],[\"dom和bom的区别是什么\",{\"0\":{\"72\":1}}],[\"dom\",{\"1\":{\"4\":1,\"88\":1}}],[\"default\",{\"1\":{\"83\":2}}],[\"defer是在等html全部解析完成后\",{\"1\":{\"79\":1}}],[\"defer与async的区别\",{\"0\":{\"79\":1}}],[\"defer延迟方式\",{\"0\":{\"78\":1}}],[\"defer\",{\"1\":{\"75\":3,\"78\":1,\"79\":2}}],[\"defineemits\",{\"1\":{\"4\":1,\"88\":1}}],[\"defineprops\",{\"1\":{\"4\":1,\"88\":1}}],[\"defineproperty\",{\"0\":{\"84\":1},\"1\":{\"3\":1,\"84\":2,\"85\":1}}],[\"dependencies都是明确分离的\",{\"1\":{\"67\":1}}],[\"dependency\",{\"0\":{\"25\":1},\"1\":{\"23\":1,\"25\":1,\"69\":1}}],[\"demo和开发调试\",{\"1\":{\"57\":1}}],[\"declarations\",{\"1\":{\"17\":1,\"20\":1,\"21\":1}}],[\"decorator\",{\"1\":{\"16\":1}}],[\"decodeuricomponent\",{\"1\":{\"7\":1}}],[\"缺点\",{\"1\":{\"4\":2,\"88\":2}}],[\"到后代组件\",{\"1\":{\"4\":1,\"88\":1}}],[\"29\",{\"0\":{\"70\":1}}],[\"28\",{\"0\":{\"69\":1}}],[\"27\",{\"0\":{\"68\":1}}],[\"26\",{\"0\":{\"67\":1}}],[\"25\",{\"0\":{\"66\":1}}],[\"24\",{\"0\":{\"65\":1}}],[\"23\",{\"0\":{\"64\":1}}],[\"22\",{\"0\":{\"63\":1}}],[\"21\",{\"0\":{\"62\":1}}],[\"200\",{\"1\":{\"90\":1}}],[\"20240518120152985\",{\"1\":{\"78\":1}}],[\"20240518115959234\",{\"1\":{\"78\":1}}],[\"20240518115317139\",{\"1\":{\"77\":1}}],[\"20240518114936359\",{\"1\":{\"77\":1}}],[\"20240518114706523\",{\"1\":{\"76\":1}}],[\"20240518113957978\",{\"1\":{\"76\":1}}],[\"20\",{\"0\":{\"61\":1}}],[\"2+\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"43\":1},\"1\":{\"4\":3,\"57\":1,\"67\":1,\"69\":1,\"82\":1,\"83\":2,\"84\":2,\"85\":1,\"88\":3}}],[\"写插件\",{\"1\":{\"4\":1,\"88\":1}}],[\"创建一个应用实例\",{\"1\":{\"4\":1,\"88\":1}}],[\"c\",{\"1\":{\"82\":2,\"83\":5,\"84\":3}}],[\"charset=\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"check是比较新的数据跟老的数据的差别\",{\"1\":{\"71\":1}}],[\"check是怎么回事\",{\"0\":{\"71\":1}}],[\"childnew\",{\"1\":{\"66\":1}}],[\"childrennewloadmodule\",{\"1\":{\"66\":1}}],[\"childrenloadmodule\",{\"1\":{\"66\":1}}],[\"children\",{\"1\":{\"66\":4}}],[\"child\",{\"1\":{\"66\":2}}],[\"currency\",{\"1\":{\"70\":1}}],[\"createembeddedview\",{\"1\":{\"31\":1}}],[\"createapp\",{\"1\":{\"4\":1,\"88\":1}}],[\"css样式以及与之相关的类\",{\"1\":{\"29\":1}}],[\"css样式和typescript类\",{\"1\":{\"12\":1}}],[\"click=\",{\"1\":{\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"cli为开发者提供了命令行工具\",{\"1\":{\"13\":1}}],[\"clear\",{\"1\":{\"31\":1}}],[\"class\",{\"0\":{\"60\":1},\"1\":{\"15\":1,\"16\":1,\"17\":1,\"20\":1,\"21\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"34\":1,\"37\":1,\"60\":1}}],[\"class=\",{\"1\":{\"8\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":3,\"96\":2}}],[\"cn\",{\"1\":{\"7\":1}}],[\"common\",{\"1\":{\"20\":1}}],[\"commonmodule\",{\"1\":{\"20\":2}}],[\"complete\",{\"1\":{\"64\":2}}],[\"complete方法的对象\",{\"1\":{\"64\":1}}],[\"components\",{\"1\":{\"69\":1,\"95\":2}}],[\"component控制视图\",{\"1\":{\"61\":1}}],[\"component和module的区别\",{\"0\":{\"61\":1}}],[\"component可创建一个view\",{\"1\":{\"46\":1}}],[\"component是可重复使用的组件\",{\"1\":{\"46\":1}}],[\"component是组件化思想\",{\"1\":{\"46\":1}}],[\"component修饰\",{\"1\":{\"46\":1}}],[\"component使用注解\",{\"1\":{\"46\":1}}],[\"component\",{\"0\":{\"15\":1,\"29\":1},\"1\":{\"16\":3,\"17\":1,\"21\":1,\"27\":2,\"28\":1,\"29\":2,\"34\":4,\"37\":2,\"48\":1,\"51\":1}}],[\"computed\",{\"1\":{\"4\":1,\"88\":1}}],[\"color\",{\"1\":{\"16\":1}}],[\"core\",{\"1\":{\"16\":1,\"17\":1,\"20\":1,\"21\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"34\":1,\"37\":1}}],[\"content=\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"contentchildren\",{\"1\":{\"74\":1}}],[\"contentchild\",{\"0\":{\"74\":1},\"1\":{\"74\":2}}],[\"content>\",{\"1\":{\"47\":1}}],[\"content>tag\",{\"1\":{\"47\":1}}],[\"content指令\",{\"0\":{\"47\":1}}],[\"content\",{\"1\":{\"39\":1,\"74\":2}}],[\"controls\",{\"1\":{\"36\":1,\"37\":1}}],[\"container\",{\"1\":{\"8\":1}}],[\"condition\",{\"1\":{\"31\":2}}],[\"constructor是执行在先的\",{\"1\":{\"65\":1}}],[\"constructor表示构造函数\",{\"1\":{\"65\":1}}],[\"constructor\",{\"0\":{\"65\":1},\"1\":{\"27\":1,\"30\":1,\"31\":1,\"37\":1,\"62\":1,\"65\":2}}],[\"const\",{\"1\":{\"7\":1,\"34\":1,\"66\":1,\"82\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"console\",{\"1\":{\"4\":1,\"7\":1,\"64\":3,\"76\":1,\"77\":1,\"78\":1,\"83\":2,\"84\":6,\"87\":1}}],[\"config\",{\"1\":{\"4\":2,\"87\":1,\"88\":1}}],[\"got\",{\"1\":{\"64\":3}}],[\"group\",{\"1\":{\"37\":1}}],[\"getelementbyid\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"get\",{\"1\":{\"37\":4,\"84\":3}}],[\"getdata\",{\"1\":{\"27\":1}}],[\"getcurrentinstance\",{\"1\":{\"4\":2,\"87\":2}}],[\"generateurl\",{\"1\":{\"7\":2}}],[\"globalproperties\",{\"1\":{\"4\":2,\"87\":1,\"88\":1}}],[\"left\",{\"1\":{\"95\":2,\"96\":2}}],[\"let\",{\"1\":{\"4\":1,\"82\":1,\"84\":4,\"87\":1,\"90\":1,\"91\":1,\"92\":2,\"93\":2,\"95\":1,\"96\":1}}],[\"lang=\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"label>\",{\"1\":{\"36\":1,\"37\":1}}],[\"limitto\",{\"1\":{\"70\":1}}],[\"lowercase\",{\"1\":{\"70\":1}}],[\"load\",{\"1\":{\"66\":2}}],[\"loadchildren\",{\"1\":{\"66\":3}}],[\"logo\",{\"1\":{\"82\":2,\"83\":4}}],[\"log\",{\"1\":{\"4\":1,\"7\":1,\"64\":2,\"76\":1,\"77\":1,\"78\":1,\"83\":2,\"84\":6,\"87\":1}}],[\"=>\",{\"1\":{\"45\":2,\"64\":3,\"82\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"=\",{\"1\":{\"4\":1,\"7\":1,\"16\":1,\"27\":2,\"29\":1,\"30\":1,\"34\":1,\"36\":3,\"37\":4,\"44\":1,\"64\":1,\"66\":1,\"76\":1,\"77\":1,\"78\":1,\"82\":3,\"83\":2,\"84\":6,\"87\":1,\"90\":3,\"91\":3,\"92\":4,\"93\":4,\"95\":2,\"96\":2}}],[\"==>\",{\"1\":{\"82\":2,\"83\":4}}],[\"==\",{\"1\":{\"4\":3,\"5\":1,\"86\":1,\"88\":2}}],[\"found\",{\"1\":{\"98\":1}}],[\"for\",{\"1\":{\"84\":1}}],[\"forchild\",{\"1\":{\"66\":1}}],[\"formcontrolname=\",{\"1\":{\"37\":1}}],[\"formgroup\",{\"1\":{\"37\":3}}],[\"formbuilder\",{\"1\":{\"37\":4}}],[\"form>\",{\"1\":{\"36\":1,\"37\":1}}],[\"form\",{\"1\":{\"36\":2,\"37\":3}}],[\"forms\",{\"1\":{\"35\":2,\"37\":1,\"73\":2}}],[\"for=\",{\"1\":{\"36\":1,\"37\":1}}],[\"forroot\",{\"1\":{\"34\":1,\"66\":1}}],[\"for优先级不同了\",{\"1\":{\"3\":1,\"85\":1}}],[\"false\",{\"1\":{\"95\":1,\"96\":1}}],[\"flex\",{\"1\":{\"95\":2,\"96\":1}}],[\"filter\",{\"1\":{\"70\":1}}],[\"from\",{\"1\":{\"4\":1,\"16\":1,\"17\":3,\"20\":2,\"21\":4,\"27\":2,\"29\":1,\"30\":1,\"31\":1,\"34\":4,\"37\":2,\"82\":1,\"87\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":3,\"96\":1}}],[\"image\",{\"1\":{\"76\":2,\"77\":2,\"78\":2}}],[\"imports\",{\"1\":{\"17\":1,\"20\":1,\"21\":1,\"34\":1}}],[\"import\",{\"1\":{\"4\":1,\"16\":1,\"17\":3,\"20\":2,\"21\":4,\"27\":2,\"29\":1,\"30\":1,\"31\":1,\"34\":4,\"37\":2,\"82\":1,\"87\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":3,\"96\":1}}],[\"is\",{\"1\":{\"36\":1,\"37\":1,\"47\":2}}],[\"id=\",{\"1\":{\"36\":1,\"37\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"initial\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"in\",{\"1\":{\"57\":1,\"84\":1}}],[\"index\",{\"1\":{\"53\":1,\"95\":1}}],[\"invalid\",{\"1\":{\"36\":1,\"37\":1}}],[\"input\",{\"1\":{\"14\":1,\"44\":1}}],[\"injectable\",{\"1\":{\"26\":1}}],[\"injection\",{\"0\":{\"25\":1},\"1\":{\"23\":1,\"25\":1,\"69\":1}}],[\"inject\",{\"1\":{\"4\":1,\"88\":1}}],[\"if=\",{\"1\":{\"95\":1,\"96\":1}}],[\"if\",{\"1\":{\"7\":1,\"31\":1,\"37\":1}}],[\"if和v\",{\"1\":{\"3\":1,\"85\":1}}],[\"面试题\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"面试汇总\",{\"0\":{\"2\":1}}],[\"show\",{\"1\":{\"95\":3,\"96\":3}}],[\"shaking\",{\"1\":{\"67\":1}}],[\"sum\",{\"1\":{\"90\":3}}],[\"subscribe\",{\"1\":{\"64\":1}}],[\"submit\",{\"1\":{\"36\":1,\"37\":1}}],[\"scale=1\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"script\",{\"0\":{\"102\":1},\"1\":{\"75\":2,\"76\":1,\"77\":1,\"78\":1}}],[\"script>\",{\"1\":{\"4\":1,\"5\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":2,\"84\":2,\"86\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":2,\"96\":1}}],[\"somethingchanged\",{\"1\":{\"44\":2}}],[\"spa\",{\"1\":{\"32\":1}}],[\"style=\",{\"1\":{\"95\":2,\"96\":1}}],[\"style>\",{\"1\":{\"95\":2,\"96\":1}}],[\"style的区别\",{\"0\":{\"60\":1}}],[\"style\",{\"1\":{\"30\":1,\"60\":1}}],[\"styles定义了内联css样式\",{\"1\":{\"16\":1}}],[\"styles\",{\"1\":{\"16\":1}}],[\"structural\",{\"0\":{\"31\":1},\"1\":{\"28\":1}}],[\"string\",{\"1\":{\"27\":1}}],[\"sex\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"services\",{\"1\":{\"69\":1}}],[\"service和有效验证\",{\"1\":{\"68\":1}}],[\"service\",{\"0\":{\"22\":1},\"1\":{\"22\":1,\"27\":1}}],[\"selector定义了在html中使用该组件的方式\",{\"1\":{\"16\":1}}],[\"selector\",{\"1\":{\"16\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"37\":1}}],[\"set\",{\"1\":{\"31\":1,\"84\":3}}],[\"setdata\",{\"1\":{\"7\":2}}],[\"setup形式\",{\"1\":{\"4\":1,\"5\":1,\"86\":1}}],[\"setup>\",{\"1\":{\"4\":1,\"5\":1,\"82\":1,\"86\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":2,\"96\":1}}],[\"src=\",{\"1\":{\"8\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":2}}],[\"slot\",{\"1\":{\"4\":1,\"88\":1}}],[\"<style>\",{\"1\":{\"95\":2,\"96\":1}}],[\"<script>\",{\"1\":{\"83\":2}}],[\"<script\",{\"1\":{\"4\":1,\"5\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"84\":2,\"86\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":2,\"96\":1}}],[\"<img\",{\"1\":{\"82\":1,\"83\":2}}],[\"<input\",{\"1\":{\"36\":1,\"37\":1}}],[\"<teleport\",{\"1\":{\"96\":1}}],[\"<template>\",{\"1\":{\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":3,\"96\":1}}],[\"<title>document<\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"<title>angular\",{\"1\":{\"17\":1}}],[\"<meta\",{\"1\":{\"76\":2,\"77\":2,\"78\":2}}],[\"<p>this\",{\"1\":{\"47\":1}}],[\"<p>data\",{\"1\":{\"27\":1}}],[\"<div\",{\"1\":{\"36\":2,\"37\":2,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":4,\"96\":2}}],[\"<div>\",{\"1\":{\"36\":1,\"37\":1}}],[\"<label\",{\"1\":{\"36\":1,\"37\":1}}],[\"<form\",{\"1\":{\"36\":1,\"37\":1}}],[\"<router\",{\"1\":{\"34\":1,\"50\":1}}],[\"<a\",{\"1\":{\"34\":2,\"95\":1}}],[\"<app\",{\"1\":{\"17\":1}}],[\"<nav>\",{\"1\":{\"34\":1}}],[\"<b\",{\"1\":{\"95\":1}}],[\"<button\",{\"1\":{\"36\":1,\"37\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"<body>\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"<base\",{\"1\":{\"17\":1}}],[\"<hr\",{\"1\":{\"82\":1,\"83\":2}}],[\"<html\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"<html>\",{\"1\":{\"17\":1}}],[\"<h1>\",{\"1\":{\"27\":1,\"51\":1}}],[\"<head>\",{\"1\":{\"17\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"<web\",{\"1\":{\"8\":1}}],[\"<view\",{\"1\":{\"8\":1}}],[\"<\",{\"1\":{\"4\":1,\"5\":1,\"8\":1,\"16\":1,\"17\":4,\"27\":2,\"29\":1,\"34\":1,\"36\":6,\"37\":6,\"51\":1,\"76\":4,\"77\":4,\"78\":4,\"82\":3,\"83\":6,\"84\":2,\"86\":1,\"90\":3,\"91\":3,\"92\":3,\"93\":3,\"95\":10,\"96\":5}}],[\"700px\",{\"1\":{\"95\":1}}],[\"7\",{\"0\":{\"48\":1},\"1\":{\"3\":1,\"4\":1,\"69\":1,\"88\":1}}],[\"$set是不存在的\",{\"1\":{\"83\":1}}],[\"$set\",{\"1\":{\"83\":1}}],[\"$set在vue3中没有\",{\"1\":{\"3\":1,\"85\":1}}],[\"$loading\",{\"1\":{\"4\":1,\"87\":1}}],[\"$ref和$children也不同\",{\"1\":{\"3\":1,\"85\":1}}],[\"6\",{\"0\":{\"47\":1},\"1\":{\"3\":1,\"4\":1,\"67\":1,\"69\":1,\"88\":1}}],[\"var\",{\"1\":{\"51\":2,\"64\":1,\"76\":1,\"77\":1,\"78\":1}}],[\"value=true\",{\"1\":{\"95\":1,\"96\":1}}],[\"value\",{\"1\":{\"44\":1,\"64\":1,\"84\":4,\"90\":2,\"93\":1}}],[\"validators\",{\"1\":{\"37\":2}}],[\"valid\",{\"1\":{\"36\":1,\"37\":2}}],[\"viewport\",{\"1\":{\"76\":1,\"77\":1,\"78\":1}}],[\"viewencapsulation\",{\"1\":{\"49\":1}}],[\"viewchildren\",{\"1\":{\"74\":1}}],[\"viewchild\",{\"0\":{\"74\":1},\"1\":{\"74\":2}}],[\"viewchid父组件通过局部变量获取子组件的引用\",{\"1\":{\"44\":1}}],[\"viewcontainer\",{\"1\":{\"31\":3}}],[\"viewcontainerref\",{\"1\":{\"31\":2}}],[\"view>\",{\"1\":{\"8\":2}}],[\"view\",{\"1\":{\"8\":1,\"14\":1,\"45\":2}}],[\"view的用法\",{\"0\":{\"6\":1}}],[\"v\",{\"1\":{\"3\":1,\"85\":1,\"95\":1,\"96\":1}}],[\"vue代码\",{\"1\":{\"95\":1}}],[\"vue\",{\"0\":{\"99\":1},\"1\":{\"4\":2,\"82\":2,\"83\":2,\"84\":6,\"87\":1,\"88\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":1}}],[\"vue3常用的响应式数据类型\",{\"0\":{\"89\":1}}],[\"vue3常用api有哪些\",{\"0\":{\"88\":1},\"1\":{\"4\":1}}],[\"vue3代码示例\",{\"0\":{\"82\":1}}],[\"vue3不需要深度监听\",{\"1\":{\"4\":1,\"88\":1}}],[\"vue3如果用setup写如何获取类似于vue2中的this\",{\"0\":{\"87\":1},\"1\":{\"4\":1}}],[\"vue3如果用setup写怎么组织代码\",{\"0\":{\"4\":1,\"5\":1,\"86\":1}}],[\"vue3可以向下兼容\",{\"1\":{\"3\":1,\"85\":1}}],[\"vue3\",{\"0\":{\"81\":1,\"103\":1},\"1\":{\"3\":2,\"85\":2}}],[\"vue2代码使用$set方法\",{\"1\":{\"83\":1}}],[\"vue2项目中使用vue3的写法\",{\"1\":{\"83\":1}}],[\"vue2使用vue3写法代码示例\",{\"0\":{\"83\":1}}],[\"vue2是选项式api\",{\"1\":{\"3\":1,\"85\":1}}],[\"vue2\",{\"0\":{\"81\":1},\"1\":{\"3\":2,\"85\":2}}],[\"vue2和vue3区别\",{\"0\":{\"3\":1,\"80\":1}}],[\"50\",{\"1\":{\"95\":2,\"96\":2}}],[\"5\",{\"0\":{\"46\":1},\"1\":{\"3\":1,\"4\":1,\"57\":1,\"67\":1,\"69\":1,\"85\":1,\"88\":1}}],[\"关于写法\",{\"1\":{\"3\":1,\"85\":1}}],[\"404\",{\"1\":{\"98\":1}}],[\"4\",{\"0\":{\"45\":1},\"1\":{\"3\":1,\"4\":1,\"57\":1,\"67\":1,\"69\":1,\"85\":1,\"88\":1}}],[\"33\",{\"0\":{\"74\":1}}],[\"32\",{\"0\":{\"73\":1}}],[\"31\",{\"0\":{\"72\":1}}],[\"300px\",{\"1\":{\"95\":3,\"96\":2}}],[\"30\",{\"0\":{\"71\":1}}],[\"3\",{\"0\":{\"44\":1},\"1\":{\"3\":1,\"4\":2,\"57\":1,\"67\":1,\"69\":1,\"82\":1,\"83\":3,\"84\":2,\"85\":1,\"88\":2}}],[\"后台管理系统\",{\"1\":{\"4\":1,\"88\":1}}],[\"后台管理系统中的按钮权限控制\",{\"1\":{\"4\":1,\"88\":1}}],[\"后添加的属性是劫持不到的\",{\"1\":{\"3\":1,\"84\":1,\"85\":1}}],[\"后端客栈\",{\"0\":{\"0\":1}}],[\"和dev\",{\"1\":{\"67\":1}}],[\"和jit编译\",{\"0\":{\"57\":1}}],[\"和promises的区别\",{\"0\":{\"54\":1}}],[\"和响应式表单\",{\"1\":{\"35\":1}}],[\"和结构指令\",{\"1\":{\"28\":1}}],[\"和元数据\",{\"1\":{\"15\":1}}],[\"和视图\",{\"1\":{\"14\":1}}],[\"和\",{\"0\":{\"60\":1,\"65\":1,\"81\":1},\"1\":{\"3\":1,\"40\":1,\"85\":1}}],[\"19\",{\"0\":{\"60\":1}}],[\"18\",{\"0\":{\"59\":1},\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"17\",{\"0\":{\"58\":1}}],[\"16\",{\"0\":{\"57\":1}}],[\"150px\",{\"1\":{\"95\":2,\"96\":2}}],[\"15\",{\"0\":{\"56\":1}}],[\"14\",{\"0\":{\"55\":1}}],[\"13\",{\"0\":{\"54\":1},\"1\":{\"4\":1,\"88\":1}}],[\"12\",{\"0\":{\"53\":1},\"1\":{\"4\":1,\"88\":1}}],[\"11\",{\"0\":{\"52\":1},\"1\":{\"4\":1,\"88\":1}}],[\"10\",{\"0\":{\"51\":1},\"1\":{\"4\":1,\"88\":1,\"90\":1}}],[\"1\",{\"0\":{\"42\":1},\"1\":{\"3\":1,\"4\":3,\"54\":1,\"57\":1,\"67\":1,\"69\":1,\"82\":1,\"83\":2,\"84\":2,\"85\":1,\"88\":3,\"95\":1,\"96\":1}}],[\"前端客栈\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
